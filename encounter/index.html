<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Encounter Manager | D&D Initiative & Combat Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- SEO -->
    <meta name="description" content="D&D encounter manager and initiative tracker. Build encounters, roll initiative, track HP, conditions, and legendary actions. Runs entirely in your browser.">
    <meta name="keywords" content="D&D, encounter manager, initiative tracker, combat tracker, DnD 5e, dungeon master tools">
    <meta name="author" content="PromptFerret">

    <!-- Open Graph -->
    <meta property="og:title" content="Encounter Manager — D&D Initiative & Combat Tracker">
    <meta property="og:description" content="Build encounters, roll initiative, and track combat. No server, no accounts — runs in your browser.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://promptferret.github.io/tools/encounter/">

    <!-- Cache Control -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

<style>
  :root {
    --bg: #0f0f17;
    --surface: #1a1a2e;
    --surface2: #252545;
    --accent: #7c5cbf;
    --accent-hover: #9b7ed8;
    --accent-glow: rgba(124, 92, 191, 0.25);
    --text: #e8e6f0;
    --text-muted: #8a8a9a;
    --text-dim: #5a5a6a;
    --border: #2a2a3e;
    --success: #4ecb71;
    --warning: #e0b055;
    --error: #e05565;
    --mono: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
    --radius: 8px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* ── Header ── */
  .header {
    padding: 1.5rem 2rem 1rem;
    text-align: center;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
  }
  .header h1 { font-size: 1.2rem; font-weight: 700; letter-spacing: -0.02em; }
  .header h1 span { color: var(--accent); }
  .header .tagline { color: var(--text-dim); font-size: 0.75rem; margin-top: 0.25rem; }

  /* ── Toolbar ── */
  .toolbar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
    flex-wrap: wrap;
  }
  .toolbar .sep { width: 1px; height: 1.5rem; background: var(--border); margin: 0 0.25rem; }
  .toolbar .spacer { flex: 1; }

  button {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 600;
    transition: all 0.15s;
    background: var(--surface2);
    color: var(--text-muted);
    white-space: nowrap;
  }
  button:hover { background: var(--accent); color: white; border-color: var(--accent); }
  button:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
  .btn-action { background: var(--accent); color: white; border-color: var(--accent); padding: 0.5rem 1.25rem; }
  .btn-action:hover { background: var(--accent-hover); border-color: var(--accent-hover); }
  .btn-toggle.active { background: var(--accent); color: white; border-color: var(--accent); }
  .btn-danger { color: var(--error); border-color: var(--error); background: transparent; }
  .btn-danger:hover { background: var(--error); color: white; }
  .btn-accent { color: var(--accent); border-color: var(--accent); background: transparent; }
  .btn-accent:hover { background: var(--accent); color: white !important; border-color: var(--accent); }
  .btn-success { color: var(--success); border-color: var(--success); background: transparent; }
  .btn-success:hover { background: var(--success); color: white !important; border-color: var(--success); }
  .btn-warning { color: var(--warning); border-color: var(--warning); background: transparent; }
  .btn-warning:hover { background: var(--warning); color: white !important; border-color: var(--warning); }
  .btn-sm { padding: 0.25rem 0.6rem; font-size: 0.72rem; }

  /* ── Status Bar ── */
  #statusEl {
    font-size: 0.75rem;
    padding: 0.35rem 1.5rem;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    min-height: 1.6rem;
  }
  #statusEl:empty { display: none; }
  #statusEl.error { color: var(--error); }
  #statusEl.success { color: var(--success); animation: status-flash 0.4s ease-out; }
  #statusEl.warning { color: var(--warning); }
  @keyframes status-flash {
    0% { background: rgba(78, 203, 113, 0.2); }
    100% { background: var(--bg); }
  }

  /* ── Main Layout ── */
  .main {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow-y: auto;
  }

  .view { display: none; padding: 1.25rem 1.5rem; }
  .view.active { display: block; }

  /* ── Cards ── */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.85rem 1rem;
    margin-bottom: 0.5rem;
    transition: border-color 0.15s;
  }
  .card:hover { border-color: var(--accent-glow); }
  .card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
  }
  .card-title {
    font-size: 0.88rem;
    font-weight: 700;
    color: var(--accent);
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .card-meta {
    font-size: 0.72rem;
    color: var(--text-dim);
    margin-top: 0.3rem;
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }
  .card-meta span { white-space: nowrap; }
  .card-actions { display: flex; gap: 0.35rem; flex-shrink: 0; }

  /* ── Forms ── */
  .form-section {
    margin-bottom: 1.25rem;
  }
  .form-section-title {
    font-size: 0.78rem;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.04em;
    margin-bottom: 0.5rem;
    padding-bottom: 0.3rem;
    border-bottom: 1px solid var(--border);
  }
  .form-grid {
    display: grid;
    gap: 0.5rem 0.75rem;
  }
  .form-grid.cols-2 { grid-template-columns: 1fr 1fr; }
  .form-grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
  .form-grid.cols-4 { grid-template-columns: 1fr 1fr 1fr 1fr; }
  .form-grid.cols-6 { grid-template-columns: repeat(6, 1fr); }
  .form-field label {
    display: block;
    font-size: 0.68rem;
    color: var(--text-dim);
    margin-bottom: 0.2rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }
  .form-field input,
  .form-field select,
  .form-field textarea {
    width: 100%;
    padding: 0.4rem 0.6rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.8rem;
    font-family: inherit;
    transition: border-color 0.2s;
  }
  .form-field input:focus,
  .form-field select:focus,
  .form-field textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }
  .form-field input::placeholder,
  .form-field textarea::placeholder { color: var(--text-dim); }
  .form-field textarea { resize: vertical; min-height: 2.5rem; font-family: var(--mono); font-size: 0.78rem; }
  .form-field select { cursor: pointer; }
  .form-field input[type="number"] { font-family: var(--mono); }
  .form-field input[type="checkbox"] { width: auto; margin-right: 0.3rem; accent-color: var(--accent); }
  .form-field .checkbox-label {
    display: inline-flex;
    align-items: center;
    font-size: 0.8rem;
    color: var(--text-muted);
    cursor: pointer;
    padding-top: 1.2rem;
  }

  /* Dynamic rows (attacks, features, etc.) */
  .dyn-row {
    display: flex;
    gap: 0.4rem;
    align-items: flex-start;
    margin-bottom: 0.35rem;
    flex-wrap: wrap;
  }
  .dyn-row input,
  .dyn-row select,
  .dyn-row textarea {
    padding: 0.35rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.78rem;
    font-family: inherit;
  }
  .dyn-row input:focus,
  .dyn-row select:focus,
  .dyn-row textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }
  .dyn-row textarea { resize: vertical; min-height: 1.8rem; font-family: var(--mono); font-size: 0.75rem; }
  .btn-remove {
    padding: 0.25rem 0.5rem;
    font-size: 0.72rem;
    color: var(--error);
    border: 1px solid var(--error);
    background: transparent;
    flex-shrink: 0;
    cursor: pointer;
    border-radius: var(--radius);
  }
  .btn-remove:hover { background: var(--error); color: white !important; }
  .dyn-label {
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    margin-bottom: 0.15rem;
  }
  .dyn-header {
    display: flex;
    gap: 0.4rem;
    margin-bottom: 0.25rem;
    padding: 0 0.1rem;
  }
  .btn-add-row {
    font-size: 0.72rem;
    padding: 0.25rem 0.75rem;
    margin-top: 0.25rem;
  }

  /* ── Form Actions ── */
  .form-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1.25rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
  }

  /* ── Empty State ── */
  .empty-state {
    text-align: center;
    color: var(--text-dim);
    padding: 3rem 1rem;
    font-size: 0.85rem;
  }
  .empty-state p { margin-bottom: 0.5rem; }

  /* ── Search Bar ── */
  .search-bar {
    margin-bottom: 0.75rem;
  }
  .search-bar input {
    width: 100%;
    padding: 0.45rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.82rem;
  }
  .search-bar input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }
  .search-bar input::placeholder { color: var(--text-dim); }

  /* ── Player List (in party form) ── */
  .player-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
    margin-top: 0.3rem;
  }
  .player-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.4rem 0.7rem;
    border: 1px solid var(--accent);
    border-radius: var(--radius);
    font-size: 0.8rem;
    background: var(--accent);
    color: white;
  }
  .player-chip .chip-remove {
    font-size: 0.65rem;
    color: var(--error);
    cursor: pointer;
    margin-left: 0.1rem;
    border: 1px solid var(--error);
    border-radius: 3px;
    padding: 0.1rem 0.25rem;
    background: transparent;
    line-height: 1;
  }
  .player-chip .chip-remove:hover { background: var(--error); color: white; }

  /* ── Monster Picks (in encounter form) ── */
  .monster-pick {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 0.3rem;
    font-size: 0.8rem;
  }
  .monster-pick .pick-name { flex: 1; color: var(--text); }
  .monster-pick .pick-qty {
    width: 50px;
    padding: 0.2rem 0.4rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.78rem;
    font-family: var(--mono);
    text-align: center;
  }

  /* ── Searchable Select ── */
  .search-select { position: relative; flex: 1; }
  .search-dropdown {
    position: absolute; top: 100%; left: 0; right: 0; z-index: 30;
    max-height: 200px; overflow-y: auto;
    background: var(--surface); border: 1px solid var(--border); border-top: none;
    border-radius: 0 0 var(--radius) var(--radius);
    display: none;
  }
  .search-dropdown.open { display: block; }
  .search-dropdown-item {
    padding: 0.4rem 0.6rem; font-size: 0.8rem; cursor: pointer;
    color: var(--text); border-bottom: 1px solid var(--border);
  }
  .search-dropdown-item:last-child { border-bottom: none; }
  .search-dropdown-item:hover { background: var(--accent); color: white; }
  .search-dropdown-item .cr-tag {
    font-size: 0.65rem; color: var(--text-dim); margin-left: 0.5rem;
  }
  .search-dropdown-item:hover .cr-tag { color: rgba(255,255,255,0.7); }

  /* ── Modal ── */
  .modal-overlay {
    position: fixed; inset: 0; z-index: 100;
    background: rgba(0,0,0,0.6); display: flex;
    align-items: center; justify-content: center;
  }
  .modal-content {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.5rem;
    max-width: 400px; width: 90%;
  }

  /* ── Footer ── */
  .footer {
    padding: 0.4rem 1.5rem;
    font-size: 0.7rem;
    color: var(--text-dim);
    border-top: 1px solid var(--border);
    background: var(--surface);
    display: flex;
    justify-content: space-between;
  }
  .footer a { color: var(--accent); text-decoration: none; }

  /* ── Combat List ── */
  .combat-list-card {
    background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
    padding: 0.75rem; margin-bottom: 0.5rem; cursor: pointer; transition: border-color 0.15s;
  }
  .combat-list-card:hover { border-color: var(--accent); }
  .combat-list-name { font-weight: 600; font-size: 0.9rem; margin-bottom: 0.3rem; }
  .combat-list-info { display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; }

  /* ── Combat ── */
  .combat-bar {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.6rem 0.75rem;
    margin: 0 -0.75rem 0.75rem;
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
    position: sticky;
    top: 0;
    background: var(--bg);
    z-index: 20;
  }
  .combat-bar .round-badge {
    font-family: var(--mono);
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--accent);
    padding: 0.3rem 0.75rem;
    border: 1px solid var(--accent);
    border-radius: var(--radius);
    white-space: nowrap;
  }

  .combatant-row {
    display: grid;
    grid-template-columns: 50px 1fr 50px 120px 40px;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 2px;
    background: var(--surface);
    cursor: pointer;
    transition: border-color 0.15s, opacity 0.15s;
  }
  .combatant-row:hover { border-color: var(--accent-glow); }
  .combatant-row.current-turn {
    border-left: 3px solid var(--accent);
    background: var(--surface2);
  }
  .combatant-row.is-dead {
    opacity: 0.35;
  }
  .combatant-row .init-val {
    font-family: var(--mono);
    font-size: 0.82rem;
    font-weight: 700;
    text-align: center;
    color: var(--text-muted);
  }
  .combatant-row .combatant-name {
    font-size: 0.85rem;
    font-weight: 600;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .combatant-row .combatant-name.type-player { color: var(--success); }
  .combatant-row .combatant-name.type-monster { color: var(--text); }
  .combatant-row .combatant-name.type-adhoc { color: var(--warning); }
  .combatant-row .ac-val {
    font-family: var(--mono);
    font-size: 0.78rem;
    text-align: center;
    color: var(--text-dim);
  }

  .hp-bar-container {
    height: 18px;
    background: var(--bg);
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid var(--border);
    position: relative;
  }
  .hp-bar-fill {
    height: 100%;
    transition: width 0.2s ease;
    border-radius: 3px;
  }
  .hp-bar-fill.hp-high { background: var(--success); }
  .hp-bar-fill.hp-mid { background: var(--warning); }
  .hp-bar-fill.hp-low { background: var(--error); }
  .hp-bar-text {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--mono);
    font-size: 0.65rem;
    font-weight: 700;
    color: var(--text);
    text-shadow: 0 0 3px var(--bg);
  }

  .reaction-indicator {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.65rem;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--text-dim);
  }
  .reaction-indicator.available { border-color: var(--success); color: var(--success); }
  .reaction-indicator.used { border-color: var(--error); color: var(--error); opacity: 0.5; }

  .combatant-detail {
    display: none;
    padding: 0.75rem;
    margin-bottom: 2px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-top: none;
    border-radius: 0 0 var(--radius) var(--radius);
  }
  .combatant-detail.expanded { display: block; }
  .detail-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
  }
  .detail-section-title {
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    margin-bottom: 0.35rem;
  }

  .init-setup-row {
    display: grid;
    grid-template-columns: 80px 1fr auto 80px;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 0.3rem;
    background: var(--surface);
  }
  .init-setup-row input[type="number"] {
    width: 100%;
    padding: 0.35rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-size: 0.82rem;
    font-family: var(--mono);
    text-align: center;
  }

  .hp-controls {
    display: flex;
    gap: 0.3rem;
    align-items: center;
    margin-top: 0.35rem;
    flex-wrap: wrap;
  }
  .hp-controls input {
    width: 60px;
    padding: 0.3rem 0.4rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    color: var(--text);
    font-family: var(--mono);
    font-size: 0.78rem;
    text-align: center;
  }

  .multiattack-box {
    font-size: 0.78rem;
    font-weight: 600;
    color: var(--warning);
    padding: 0.35rem 0.6rem;
    margin-top: 0.5rem;
    background: rgba(224, 176, 85, 0.08);
    border: 1px solid rgba(224, 176, 85, 0.25);
    border-radius: var(--radius);
    border-left: 3px solid var(--warning);
  }

  .roll-log {
    font-family: var(--mono);
    font-size: 0.75rem;
    background: var(--bg);
    border-radius: var(--radius);
    border: 1px solid var(--border);
    padding: 0.4rem 0.6rem;
    margin-top: 0.5rem;
  }
  .roll-log-entry {
    color: var(--accent);
    padding: 0.1rem 0;
  }
  .roll-log-entry.crit { color: var(--success); font-weight: 700; }
  .roll-log-entry.fumble { color: var(--error); font-weight: 700; }

  .dice-link {
    color: var(--accent);
    cursor: pointer;
    text-decoration: underline;
    font-family: var(--mono);
  }
  .dice-link:hover { color: var(--text); }

  .la-badge, .lr-badge {
    font-family: var(--mono);
    font-size: 0.6rem;
    padding: 0.05rem 0.3rem;
    border-radius: 4px;
    margin-left: 0.3rem;
  }
  .la-badge { background: rgba(224, 176, 85, 0.15); color: var(--warning); }
  .lr-badge { background: rgba(191, 92, 92, 0.15); color: var(--error); }

  .condition-chip {
    display: inline-block;
    font-size: 0.6rem;
    font-weight: 600;
    padding: 0.1rem 0.4rem;
    border-radius: 9px;
    background: rgba(124, 92, 191, 0.15);
    color: var(--accent);
    border: 1px solid rgba(124, 92, 191, 0.3);
    margin: 0.08rem;
    white-space: nowrap;
  }
  .condition-chip.save-based { background: rgba(224, 176, 85, 0.12); color: var(--warning); border-color: rgba(224, 176, 85, 0.3); }
  .turn-notify {
    font-size: 0.58rem;
    font-weight: 700;
    color: var(--warning);
    background: rgba(224, 176, 85, 0.15);
    border: 1px solid rgba(224, 176, 85, 0.3);
    border-radius: 9px;
    padding: 0.05rem 0.35rem;
    margin-left: 0.2rem;
    white-space: nowrap;
    animation: notify-pulse 1.5s ease-in-out 3;
  }
  @keyframes notify-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .concentration-chip {
    display: inline-block;
    font-size: 0.6rem;
    font-weight: 600;
    padding: 0.1rem 0.4rem;
    border-radius: 9px;
    background: rgba(92, 191, 124, 0.12);
    color: var(--success);
    border: 1px solid rgba(92, 191, 124, 0.3);
    margin: 0.05rem;
    white-space: nowrap;
  }

  /* ── Responsive ── */
  @supports (height: 100dvh) { body { height: 100dvh; } }
  @media (max-width: 640px) {
    .toolbar { flex-wrap: wrap; }
    .form-grid.cols-3,
    .form-grid.cols-4 { grid-template-columns: 1fr 1fr; }
    .form-grid.cols-6 { grid-template-columns: repeat(3, 1fr); }
    .view { padding: 1rem; }
    .combatant-row { grid-template-columns: 40px 1fr 40px 80px 30px; }
    .init-setup-row { grid-template-columns: 80px 1fr 80px; }
    .init-setup-row > span:nth-child(3) { display: none; }
    .detail-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<div class="header">
  <h1><span>Encounter</span> Manager</h1>
  <p class="tagline">D&D initiative & combat tracker</p>
</div>

<div class="toolbar">
  <button class="btn-toggle active" id="navTemplates" onclick="switchView('templates')">Monsters</button>
  <button class="btn-toggle" id="navParties" onclick="switchView('parties')">Parties</button>
  <button class="btn-toggle" id="navEncounters" onclick="switchView('encounters')">Encounters</button>
  <button class="btn-toggle" id="navCombat" onclick="switchView('combat')">Combat</button>
  <div class="spacer"></div>
  <button class="btn-sm" onclick="showImportDialog()" title="Load backup">Load Backup</button>
  <button class="btn-sm" onclick="exportData()" title="Save backup">Save Backup</button>
  <div class="sep"></div>
  <button class="btn-sm" id="btnImportMonster" onclick="showImportMonsterDialog()">Import Monster</button>
  <button class="btn-action" id="btnNew" onclick="handleNew()">+ New Monster</button>
</div>

<div id="statusEl"></div>

<div class="main">
  <div id="viewTemplates" class="view active"></div>
  <div id="viewParties" class="view"></div>
  <div id="viewEncounters" class="view"></div>
  <div id="viewCombat" class="view"></div>
</div>

<div class="footer">
  <span><a href="https://promptferret.github.io">PromptFerret</a> &middot; <a href="https://github.com/PromptFerret/tools/blob/main/LICENSE" target="_blank">MIT License</a> &middot; Vibe coded with <a href="https://docs.anthropic.com/en/docs/claude-code" target="_blank">Claude Code</a></span>
  <span><a href="../">All Tools</a> &middot; <span id="storageInfo">Data stored in your browser</span></span>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// ── Constants ──
// ═══════════════════════════════════════════════════════════════

const ABILITIES = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
const ABILITY_NAMES = { str: 'Strength', dex: 'Dexterity', con: 'Constitution', int: 'Intelligence', wis: 'Wisdom', cha: 'Charisma' };
const SKILLS = [
  'Acrobatics', 'Animal Handling', 'Arcana', 'Athletics', 'Deception',
  'History', 'Insight', 'Intimidation', 'Investigation', 'Medicine',
  'Nature', 'Perception', 'Performance', 'Persuasion', 'Religion',
  'Sleight of Hand', 'Stealth', 'Survival'
];
const SIZES = ['Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan'];
const CONDITIONS = ['Blinded','Charmed','Deafened','Frightened','Grappled','Incapacitated','Invisible','Paralyzed','Petrified','Poisoned','Prone','Restrained','Stunned','Unconscious'];
const STORAGE_KEYS = {
  templates: 'pf_enc_templates',
  groups: 'pf_enc_groups',
  encounters: 'pf_enc_encounters',
  parties: 'pf_enc_parties',
  combats: 'pf_enc_combats'
};

// ═══════════════════════════════════════════════════════════════
// ── State ──
// ═══════════════════════════════════════════════════════════════

let state = {
  templates: [],
  groups: [],
  encounters: [],
  parties: [],
  combats: []
};

let currentView = 'templates';
let formMode = null;   // null = list, 'template' = editing template, 'encounter' = editing encounter, 'party' = editing party
let formData = null;   // working copy of the item being edited
let savedFormSnapshot = null; // snapshot of formData at last save, for dirty checking
let searchQuery = '';
let activeCombatId = null; // transient — ID of the combat currently being viewed

function getActiveCombat() {
  if (!activeCombatId) return null;
  return state.combats.find(c => c.id === activeCombatId) || null;
}

// ═══════════════════════════════════════════════════════════════
// ── Utilities ──
// ═══════════════════════════════════════════════════════════════

function uuid() { return crypto.randomUUID(); }
function abilityMod(score) { return Math.floor((score - 10) / 2); }
function modStr(score) { const m = abilityMod(score); return m >= 0 ? '+' + m : '' + m; }
function esc(s) { if (!s) return ''; return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); }

function setStatus(msg, type) {
  const el = document.getElementById('statusEl');
  el.textContent = msg;
  el.className = '';
  void el.offsetWidth; // force reflow to restart animation
  el.className = type || '';
}

function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }
function isFormDirty() { return JSON.stringify(formData) !== JSON.stringify(savedFormSnapshot); }

function calcPassivePerception(t) {
  const wisMod = abilityMod(t.abilities.wis);
  const percSkill = t.skills.find(s => s.name === 'Perception');
  return 10 + (percSkill ? percSkill.bonus : wisMod);
}

function getPassivePerception(t) {
  return t.passivePerception != null ? t.passivePerception : calcPassivePerception(t);
}

function updatePPDisplay() {
  const auto = calcPassivePerception(formData);
  const lbl = document.getElementById('pp_auto');
  const inp = document.getElementById('pp_input');
  if (lbl) lbl.textContent = auto;
  if (inp) inp.placeholder = auto;
}

function newTemplate() {
  return {
    id: uuid(), name: '', size: 'Medium', type: '', alignment: '', ac: 10, acNote: '',
    hpMax: 1, hpFormula: '', speed: '30 ft.', cr: '',
    abilities: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
    savingThrows: [], skills: [],
    damageResistances: '', damageImmunities: '', conditionImmunities: '', damageVulnerabilities: '',
    senses: '', passivePerception: null, languages: '', tactics: '',
    initBonus: 0, initAdvantage: false, critRange: 20,
    attacks: [], // each: { name, bonus, note, damages: [{ dice, type, note }] }
    multiattack: '',
    features: [],
    legendaryActionBudget: 0, legendaryActions: [], legendaryResistances: 0,
    groups: []
  };
}

function newEncounter() {
  return { id: uuid(), name: '', location: '', campaign: '', notes: '', monsters: [] };
}

function newParty() {
  return { id: uuid(), name: '', players: [] };
}

// ═══════════════════════════════════════════════════════════════
// ── Storage (IndexedDB with localStorage fallback) ──
// ═══════════════════════════════════════════════════════════════

const DB_NAME = 'pf_encounter';
const DB_VERSION = 1;
const DB_STORE = 'state';
let _db = null;
let _useLocalStorage = false;

function openDB() {
  if (_db) return Promise.resolve(_db);
  return new Promise((resolve, reject) => {
    try {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => { req.result.createObjectStore(DB_STORE); };
      req.onsuccess = () => { _db = req.result; resolve(_db); };
      req.onerror = () => { reject(req.error); };
    } catch (e) { reject(e); }
  });
}

function idbGet(db, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, 'readonly');
    const req = tx.objectStore(DB_STORE).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function idbPut(key, value) {
  if (!_db) return;
  try {
    const tx = _db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).put(value, STORAGE_KEYS[key]);
  } catch (e) {
    console.error('IndexedDB write failed:', e);
  }
}

async function load() {
  try {
    const db = await openDB();
    let hasIdbData = false;
    for (const [key, skey] of Object.entries(STORAGE_KEYS)) {
      const val = await idbGet(db, skey);
      if (val !== undefined) { state[key] = val; hasIdbData = true; }
    }
    // Migrate old single combat → combats array (Phase 3.5 → Phase 4)
    const oldCombat = await idbGet(db, 'pf_enc_combat');
    if (oldCombat !== undefined) {
      state.combats = oldCombat ? [Object.assign({ id: oldCombat.id || uuid() }, oldCombat)] : [];
      try {
        const tx = _db.transaction(DB_STORE, 'readwrite');
        tx.objectStore(DB_STORE).put(state.combats, 'pf_enc_combats');
        tx.objectStore(DB_STORE).delete('pf_enc_combat');
      } catch (e) { /* best effort */ }
      console.log('Migrated single combat to combats array');
    }
    // Clean up old shared player roster key (Phase 4.1 — players now per-party)
    try {
      const tx2 = _db.transaction(DB_STORE, 'readwrite');
      tx2.objectStore(DB_STORE).delete('pf_enc_players');
    } catch (e) { /* best effort */ }
    // Auto-migrate from localStorage if IndexedDB was empty
    if (!hasIdbData && oldCombat === undefined) {
      let migrated = false;
      // Check both old and new key names
      for (const [key, skey] of Object.entries(STORAGE_KEYS)) {
        try {
          const raw = localStorage.getItem(skey);
          if (raw) { state[key] = JSON.parse(raw); migrated = true; }
        } catch (e) { /* ignore parse errors */ }
      }
      // Also check old single-combat localStorage key
      try {
        const oldRaw = localStorage.getItem('pf_enc_combat');
        if (oldRaw) {
          const oldC = JSON.parse(oldRaw);
          state.combats = oldC ? [Object.assign({ id: oldC.id || uuid() }, oldC)] : [];
          migrated = true;
        }
      } catch (e) { /* ignore */ }
      if (migrated) {
        for (const [k, skey] of Object.entries(STORAGE_KEYS)) {
          try { _db.transaction(DB_STORE, 'readwrite').objectStore(DB_STORE).put(state[k], skey); } catch (e) { /* best effort */ }
        }
        for (const skey of [...Object.values(STORAGE_KEYS), 'pf_enc_combat', 'pf_enc_players']) {
          try { localStorage.removeItem(skey); } catch (e) { /* best effort */ }
        }
        console.log('Migrated data from localStorage to IndexedDB');
      }
    }
  } catch (e) {
    console.warn('IndexedDB unavailable, falling back to localStorage:', e);
    _useLocalStorage = true;
    try {
      for (const [key, skey] of Object.entries(STORAGE_KEYS)) {
        const raw = localStorage.getItem(skey);
        if (raw) state[key] = JSON.parse(raw);
      }
      // Also check old single-combat key
      if (!state.combats.length) {
        const oldRaw = localStorage.getItem('pf_enc_combat');
        if (oldRaw) {
          const oldC = JSON.parse(oldRaw);
          state.combats = oldC ? [Object.assign({ id: oldC.id || uuid() }, oldC)] : [];
          localStorage.removeItem('pf_enc_combat');
        }
      }
    } catch (e2) {
      console.error('Failed to load state:', e2);
    }
  }
}

function save(key) {
  if (_useLocalStorage) {
    try {
      if (key) {
        localStorage.setItem(STORAGE_KEYS[key], JSON.stringify(state[key]));
      } else {
        for (const [k, skey] of Object.entries(STORAGE_KEYS)) {
          localStorage.setItem(skey, JSON.stringify(state[k]));
        }
      }
    } catch (e) {
      console.error('Failed to save state:', e);
      setStatus('Failed to save — storage may be full.', 'error');
    }
    return;
  }
  if (key) {
    idbPut(key, state[key]);
  } else {
    for (const [k] of Object.entries(STORAGE_KEYS)) {
      idbPut(k, state[k]);
    }
  }
  clearTimeout(save._storageTimer);
  save._storageTimer = setTimeout(updateStorageInfo, 2000);
}

// ═══════════════════════════════════════════════════════════════
// ── Dice Engine ──
// ═══════════════════════════════════════════════════════════════

function rollDice(notation, opts = {}) {
  const match = notation.trim().match(/^(\d+)d(\d+)\s*([+-]\s*\d+)?$/i);
  if (!match) return { rolls: [], modifier: 0, total: 0, text: 'Invalid: ' + notation };
  const count = parseInt(match[1]);
  const sides = parseInt(match[2]);
  const modifier = match[3] ? parseInt(match[3].replace(/\s/g, '')) : 0;
  const rolls = [];
  for (let i = 0; i < count; i++) rolls.push(Math.floor(Math.random() * sides) + 1);

  if (opts.advantage || opts.disadvantage) {
    // For d20 rolls with adv/dis: roll twice, pick higher/lower
    if (count === 1 && sides === 20) {
      const second = Math.floor(Math.random() * 20) + 1;
      const both = [rolls[0], second];
      const pick = opts.advantage ? Math.max(...both) : Math.min(...both);
      const label = opts.advantage ? 'adv' : 'dis';
      return {
        rolls: both, modifier, total: pick + modifier,
        text: '[' + both.join(', ') + '] → ' + pick + (modifier ? (modifier > 0 ? ' + ' : ' - ') + Math.abs(modifier) + ' = ' + (pick + modifier) : '') + ' (' + label + ')'
      };
    }
  }

  const sum = rolls.reduce((a, b) => a + b, 0);
  const total = sum + modifier;
  let text = '[' + rolls.join(', ') + ']';
  if (modifier) text += (modifier > 0 ? ' + ' : ' - ') + Math.abs(modifier) + ' = ' + total;
  else if (rolls.length > 1) text += ' = ' + total;
  return { rolls, modifier, total, text };
}

function renderDiceText(text, combatantIdx, sourceType, sourceIdx) {
  return text.replace(/(\d+d\d+(?:[+-]\d+)?)/gi, function(match) {
    var args = combatantIdx + ',\'' + match + '\'';
    if (sourceType !== undefined) args += ',\'' + sourceType + '\',' + sourceIdx;
    return '<span class="dice-link" onclick="event.stopPropagation();rollInlineDice(' + args + ')">' + match + '</span>';
  });
}

function rollInlineDice(combatantIdx, notation, sourceType, sourceIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  if (!c.rollLog) c.rollLog = [];
  const result = rollDice(notation);
  var label = notation;
  if (sourceType && sourceIdx !== undefined) {
    const template = getTemplate(c);
    if (template) {
      if (sourceType === 'feature' && template.features[sourceIdx]) label = esc(template.features[sourceIdx].name) + ': ' + notation;
      else if (sourceType === 'la' && template.legendaryActions[sourceIdx]) label = esc(template.legendaryActions[sourceIdx].name) + ': ' + notation;
    }
  }
  c.rollLog.push({ label: label, text: esc(result.text) + (result.text.indexOf('=') === -1 ? ' = ' + result.total : ''), cssClass: '' });
  saveCombat();
  renderRollLog(combatantIdx);
}

// ═══════════════════════════════════════════════════════════════
// ── Compression (SquishText-compatible) ──
// ═══════════════════════════════════════════════════════════════

const crcTable = new Uint32Array(256);
for (let i = 0; i < 256; i++) {
  let c = i;
  for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
  crcTable[i] = c;
}
function crc32(str) {
  let crc = 0xFFFFFFFF;
  for (let i = 0; i < str.length; i++) crc = crcTable[(crc ^ str.charCodeAt(i)) & 0xFF] ^ (crc >>> 8);
  return ((crc ^ 0xFFFFFFFF) >>> 0).toString(16).padStart(8, '0');
}

async function compress(text) {
  const encoder = new TextEncoder();
  const stream = new Blob([encoder.encode(text)])
    .stream()
    .pipeThrough(new CompressionStream('deflate-raw'));
  const blob = await new Response(stream).blob();
  const buffer = await blob.arrayBuffer();
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  const b64 = btoa(binary);
  return b64 + '.' + crc32(b64);
}

async function decompress(base64) {
  base64 = base64.replace(/^\[SquishText\][^\n]*\n?/, '');
  base64 = base64.trim().replace(/[\r\n\s]/g, '');
  base64 = base64.replace(/-/g, '+').replace(/_/g, '/');
  const dotIdx = base64.lastIndexOf('.');
  if (dotIdx > 0 && base64.length - dotIdx - 1 === 8) {
    const data = base64.slice(0, dotIdx);
    const checksum = base64.slice(dotIdx + 1).toLowerCase();
    if (crc32(data) !== checksum) throw new Error('Checksum mismatch — data may be corrupted.');
    base64 = data;
  }
  while (base64.length % 4 !== 0) base64 += '=';
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  const stream = new Blob([bytes])
    .stream()
    .pipeThrough(new DecompressionStream('deflate-raw'));
  const blob = await new Response(stream).blob();
  return await blob.text();
}

// ═══════════════════════════════════════════════════════════════
// ── Combat Helpers ──
// ═══════════════════════════════════════════════════════════════

function saveCombat() { save('combats'); }

function getTemplate(c) {
  return c.type === 'monster' ? state.templates.find(t => t.id === c.templateId) : null;
}

function resolveField(c, field) {
  if (c.overrides && c.overrides[field] !== undefined) return c.overrides[field];
  if (c.type === 'monster') {
    const t = getTemplate(c);
    return t ? t[field] : undefined;
  }
  return undefined;
}

// ═══════════════════════════════════════════════════════════════
// ── View Management ──
// ═══════════════════════════════════════════════════════════════

function switchView(view) {
  // Check for unsaved form changes before switching
  if (formMode && isFormDirty()) {
    if (!confirm('You have unsaved changes. Leave without saving?')) return;
  }
  formMode = null;
  formData = null;
  savedFormSnapshot = null;
  searchQuery = '';

  currentView = view;
  // When navigating to combat via tab, show the combat list (not last-viewed combat)
  if (view === 'combat' && !pendingCombatEncounterId) {
    activeCombatId = null;
  }
  ['templates', 'parties', 'encounters', 'combat'].forEach(v => {
    document.getElementById('nav' + v.charAt(0).toUpperCase() + v.slice(1)).classList.toggle('active', view === v);
    document.getElementById('view' + v.charAt(0).toUpperCase() + v.slice(1)).classList.toggle('active', view === v);
  });

  const btnNew = document.getElementById('btnNew');
  btnNew.style.display = view === 'combat' ? 'none' : '';
  const labels = { templates: '+ New Monster', parties: '+ New Party', encounters: '+ New Encounter' };
  btnNew.textContent = labels[view] || '';
  document.getElementById('btnImportMonster').style.display = view === 'templates' ? '' : 'none';

  render();
}

function handleNew() {
  if (currentView === 'templates') showTemplateForm(null);
  else if (currentView === 'parties') showPartyForm(null);
  else if (currentView === 'encounters') showEncounterForm(null);
}

function render() {
  if (currentView === 'templates') {
    if (formMode === 'template') renderTemplateForm();
    else renderTemplateList();
  } else if (currentView === 'parties') {
    if (formMode === 'party') renderPartyForm();
    else renderPartyList();
  } else if (currentView === 'encounters') {
    if (formMode === 'encounter') renderEncounterForm();
    else renderEncounterList();
  } else if (currentView === 'combat') {
    renderCombatView();
  }
}

// ═══════════════════════════════════════════════════════════════
// ── Template List ──
// ═══════════════════════════════════════════════════════════════

function renderTemplateList() {
  const el = document.getElementById('viewTemplates');
  document.getElementById('btnNew').style.display = '';

  const filtered = state.templates.filter(t =>
    !searchQuery || t.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  let html = '<div class="search-bar"><input type="text" placeholder="Search monsters..." value="' + esc(searchQuery) + '" oninput="searchQuery=this.value;renderTemplateList()"></div>';

  if (filtered.length === 0) {
    if (state.templates.length === 0) {
      html += '<div class="empty-state"><p>No monsters yet.</p><p>Click <strong>+ New Monster</strong> to create one.</p></div>';
    } else {
      html += '<div class="empty-state"><p>No monsters match your search.</p></div>';
    }
  } else {
    filtered.forEach(t => {
      const meta = [];
      if (t.size) meta.push(t.size);
      if (t.type) meta.push(t.type);
      if (t.alignment) meta.push(t.alignment);
      if (t.cr) meta.push('CR ' + t.cr);
      meta.push('AC ' + t.ac);
      meta.push(t.hpMax + ' HP');
      meta.push('PP ' + getPassivePerception(t));
      if (t.attacks.length) meta.push(t.attacks.length + ' attack' + (t.attacks.length > 1 ? 's' : ''));
      if (t.legendaryActionBudget > 0) meta.push('Legendary');

      html += '<div class="card">';
      html += '<div class="card-header">';
      html += '<span class="card-title">' + esc(t.name || 'Unnamed') + '</span>';
      html += '<div class="card-actions">';
      html += '<button class="btn-sm" onclick="showTemplateForm(\'' + t.id + '\')">Edit</button>';
      html += '<button class="btn-sm" onclick="exportMonster(\'' + t.id + '\')">Export</button>';
      html += '<button class="btn-sm btn-danger" onclick="deleteTemplate(\'' + t.id + '\')">Delete</button>';
      html += '</div></div>';
      html += '<div class="card-meta">' + meta.map(m => '<span>' + esc(m) + '</span>').join('') + '</div>';
      html += '</div>';
    });
  }

  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Template Form ──
// ═══════════════════════════════════════════════════════════════

function showTemplateForm(id) {
  formMode = 'template';
  if (id) {
    const t = state.templates.find(t => t.id === id);
    if (!t) { setStatus('Monster not found.', 'error'); return; }
    formData = deepClone(t);
  } else {
    formData = newTemplate();
  }
  savedFormSnapshot = deepClone(formData);
  document.getElementById('btnNew').style.display = 'none';
  renderTemplateForm();
}

function renderTemplateForm() {
  const d = formData;
  const el = document.getElementById('viewTemplates');

  let html = '';

  // ── Basic Info ──
  html += '<div class="form-section"><div class="form-section-title">Basic Info</div>';
  html += '<div class="form-grid cols-4">';
  html += formField('Name', 'text', d.name, 'formData.name=this.value', 'Goblin');
  html += formField('Size', 'select', d.size, 'formData.size=this.value', null, SIZES);
  html += formField('Type', 'text', d.type, 'formData.type=this.value', 'Humanoid');
  html += formField('Alignment', 'text', d.alignment, 'formData.alignment=this.value', 'Unaligned');
  html += '</div>';
  html += '<div class="form-grid cols-4" style="margin-top:0.5rem">';
  html += formField('AC', 'number', d.ac, 'formData.ac=+this.value');
  html += formField('AC Note', 'text', d.acNote, 'formData.acNote=this.value', 'natural armor');
  html += formField('HP Max', 'number', d.hpMax, 'formData.hpMax=+this.value');
  html += '<div class="form-field"><label>HP Formula</label><div style="display:flex;gap:0.3rem"><input type="text" value="' + esc(d.hpFormula) + '" onchange="formData.hpFormula=this.value" placeholder="2d6" style="flex:1"><button class="btn-sm" onclick="hpFromFormula(\'avg\')" title="Set HP Max to formula average">Avg</button><button class="btn-sm" onclick="hpFromFormula(\'roll\')" title="Roll HP from formula">Roll</button></div></div>';
  html += '</div>';
  html += '<div class="form-grid cols-4" style="margin-top:0.5rem">';
  html += formField('Speed', 'text', d.speed, 'formData.speed=this.value', '30 ft.');
  html += formField('CR', 'text', d.cr, 'formData.cr=this.value', '1/4');
  html += formField('Init Bonus', 'number', d.initBonus, 'formData.initBonus=+this.value');
  html += '<div class="form-field"><label class="checkbox-label"><input type="checkbox" ' + (d.initAdvantage ? 'checked' : '') + ' onchange="formData.initAdvantage=this.checked"> Init Advantage</label></div>';
  html += '</div></div>';

  // ── Ability Scores ──
  html += '<div class="form-section"><div class="form-section-title">Ability Scores</div>';
  html += '<div class="form-grid cols-6">';
  ABILITIES.forEach(ab => {
    const score = d.abilities[ab];
    html += '<div class="form-field"><label>' + ab.toUpperCase() + ' (<span id="mod_' + ab + '">' + modStr(score) + '</span>)</label>';
    const extra = ab === 'wis' ? ';updatePPDisplay()' : '';
    html += '<input type="number" value="' + score + '" onchange="formData.abilities.' + ab + '=+this.value;document.getElementById(\'mod_' + ab + '\').textContent=modStr(+this.value)' + extra + '">';
    html += '</div>';
  });
  html += '</div></div>';

  // ── Saving Throws ──
  html += '<div class="form-section"><div class="form-section-title">Saving Throws</div>';
  d.savingThrows.forEach((st, i) => {
    html += '<div class="dyn-row">';
    html += '<select onchange="formData.savingThrows[' + i + '].ability=this.value" style="width:120px">';
    ABILITIES.forEach(ab => {
      html += '<option value="' + ab + '"' + (st.ability === ab ? ' selected' : '') + '>' + ABILITY_NAMES[ab] + '</option>';
    });
    html += '</select>';
    html += '<input type="number" value="' + st.bonus + '" onchange="formData.savingThrows[' + i + '].bonus=+this.value" style="width:60px" placeholder="+0">';
    html += '<button class="btn-remove" onclick="formData.savingThrows.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
  });
  html += '<button class="btn-add-row" onclick="formData.savingThrows.push({ability:\'str\',bonus:0});renderTemplateForm()">+ Add Save</button>';
  html += '</div>';

  // ── Skills ──
  html += '<div class="form-section"><div class="form-section-title">Skills</div>';
  d.skills.forEach((sk, i) => {
    html += '<div class="dyn-row">';
    html += '<select onchange="formData.skills[' + i + '].name=this.value" style="width:150px">';
    SKILLS.forEach(s => {
      html += '<option value="' + s + '"' + (sk.name === s ? ' selected' : '') + '>' + s + '</option>';
    });
    html += '</select>';
    html += '<input type="number" value="' + sk.bonus + '" onchange="formData.skills[' + i + '].bonus=+this.value" style="width:60px" placeholder="+0">';
    html += '<button class="btn-remove" onclick="formData.skills.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
  });
  html += '<button class="btn-add-row" onclick="formData.skills.push({name:\'Perception\',bonus:0});renderTemplateForm()">+ Add Skill</button>';
  html += '</div>';

  // ── Defenses ──
  html += '<div class="form-section"><div class="form-section-title">Defenses & Senses</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Damage Resistances', 'text', d.damageResistances, 'formData.damageResistances=this.value', 'fire, cold');
  html += formField('Damage Immunities', 'text', d.damageImmunities, 'formData.damageImmunities=this.value', 'poison');
  html += formField('Damage Vulnerabilities', 'text', d.damageVulnerabilities, 'formData.damageVulnerabilities=this.value', 'radiant');
  html += formField('Condition Immunities', 'text', d.conditionImmunities, 'formData.conditionImmunities=this.value', 'frightened');
  html += formField('Senses', 'text', d.senses, 'formData.senses=this.value', 'darkvision 60 ft.');
  html += formField('Languages', 'text', d.languages, 'formData.languages=this.value', 'Common, Goblin');
  html += '</div>';
  html += '<div class="form-grid cols-2" style="margin-top:0.5rem">';
  html += '<div class="form-field"><label>Passive Perception (auto: <span id="pp_auto">' + calcPassivePerception(d) + '</span>)</label>';
  html += '<input type="number" id="pp_input" value="' + (d.passivePerception != null ? d.passivePerception : '') + '" onchange="formData.passivePerception=this.value===\'\'?null:+this.value;updatePPDisplay()" placeholder="' + calcPassivePerception(d) + '">';
  html += '</div>';
  html += '<div class="form-field"></div>';
  html += '</div></div>';

  // ── Attacks ──
  html += '<div class="form-section"><div class="form-section-title">Attacks</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Multiattack', 'text', d.multiattack, 'formData.multiattack=this.value', 'Two claw attacks');
  html += formField('Crits On', 'number', d.critRange || 20, 'formData.critRange=+this.value||20', '20');
  html += '</div>';
  html += '<div style="margin-top:0.5rem">';
  d.attacks.forEach((a, i) => {
    html += '<div class="card" style="padding:0.6rem 0.75rem;margin-bottom:0.4rem">';
    // Attack header row: name, bonus, note, remove
    if (i === 0) {
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="flex:2">Name</span>';
      html += '<span class="dyn-label" style="width:55px">Hit</span>';
      html += '<span class="dyn-label" style="flex:1">Note</span>';
      html += '<span style="width:30px"></span>';
      html += '</div>';
    }
    html += '<div class="dyn-row" style="margin-bottom:0.3rem">';
    html += '<input type="text" value="' + esc(a.name) + '" onchange="formData.attacks[' + i + '].name=this.value" placeholder="Scimitar" style="flex:2">';
    html += '<input type="number" value="' + a.bonus + '" onchange="formData.attacks[' + i + '].bonus=+this.value" placeholder="+4" style="width:55px">';
    html += '<input type="text" value="' + esc(a.note || '') + '" onchange="formData.attacks[' + i + '].note=this.value" placeholder="reach 10ft" style="flex:1">';
    html += '<button class="btn-remove" onclick="formData.attacks.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
    // Damage rows
    if (a.damages && a.damages.length > 0) {
      html += '<div style="padding-left:0.75rem;border-left:2px solid var(--border)">';
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="width:80px">Damage</span>';
      html += '<span class="dyn-label" style="width:80px">Type</span>';
      html += '<span class="dyn-label" style="flex:1">Note</span>';
      html += '<span style="width:30px"></span>';
      html += '</div>';
      a.damages.forEach((dm, j) => {
        html += '<div class="dyn-row">';
        html += '<input type="text" value="' + esc(dm.dice) + '" onchange="formData.attacks[' + i + '].damages[' + j + '].dice=this.value" placeholder="1d8+2" style="width:80px" title="Damage dice">';
        html += '<input type="text" value="' + esc(dm.type) + '" onchange="formData.attacks[' + i + '].damages[' + j + '].type=this.value" placeholder="slashing" style="width:80px" title="Damage type">';
        html += '<input type="text" value="' + esc(dm.note || '') + '" onchange="formData.attacks[' + i + '].damages[' + j + '].note=this.value" placeholder="note" style="flex:1" title="Damage note">';
        html += '<button class="btn-remove" onclick="formData.attacks[' + i + '].damages.splice(' + j + ',1);renderTemplateForm()">×</button>';
        html += '</div>';
      });
      html += '</div>';
    }
    html += '<button class="btn-add-row btn-sm" onclick="formData.attacks[' + i + '].damages.push({dice:\'\',type:\'\',note:\'\'});renderTemplateForm()" style="margin-left:0.75rem">+ Damage</button>';
    html += '</div>';
  });
  html += '</div>';
  html += '<button class="btn-add-row" onclick="formData.attacks.push({name:\'\',bonus:0,note:\'\',damages:[{dice:\'\',type:\'\',note:\'\'}]});renderTemplateForm()">+ Add Attack</button>';
  html += '</div>';

  // ── Features ──
  html += '<div class="form-section"><div class="form-section-title">Features & Abilities</div>';
  if (d.features.length > 0) {
    html += '<div class="dyn-header">';
    html += '<span class="dyn-label" style="flex:2">Name</span>';
    html += '<span class="dyn-label" style="width:100px">Recharge</span>';
    html += '<span class="dyn-label" style="width:55px">Uses</span>';
    html += '<span style="width:30px"></span>';
    html += '</div>';
  }
  d.features.forEach((f, i) => {
    html += '<div class="dyn-row" style="flex-direction:column">';
    html += '<div style="display:flex;gap:0.4rem;width:100%">';
    html += '<input type="text" value="' + esc(f.name) + '" onchange="formData.features[' + i + '].name=this.value" placeholder="Feature name" style="flex:2">';
    html += '<input type="text" value="' + esc(f.recharge || '') + '" onchange="formData.features[' + i + '].recharge=this.value||null" placeholder="5-6" style="width:100px">';
    html += '<input type="number" value="' + (f.usesMax || '') + '" onchange="formData.features[' + i + '].usesMax=+this.value||null;formData.features[' + i + '].uses=+this.value||null" placeholder="#" style="width:55px">';
    html += '<button class="btn-remove" onclick="formData.features.splice(' + i + ',1);renderTemplateForm()">×</button>';
    html += '</div>';
    html += '<textarea onchange="formData.features[' + i + '].desc=this.value" placeholder="Description..." style="width:100%">' + esc(f.desc) + '</textarea>';
    html += '</div>';
  });
  html += '<button class="btn-add-row" onclick="formData.features.push({name:\'\',desc:\'\',recharge:null,uses:null,usesMax:null});renderTemplateForm()">+ Add Feature</button>';
  html += '</div>';

  // ── Legendary ──
  html += '<div class="form-section"><div class="form-section-title">Legendary</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Actions/Round', 'number', d.legendaryActionBudget, 'formData.legendaryActionBudget=+this.value');
  html += formField('Resistances', 'number', d.legendaryResistances, 'formData.legendaryResistances=+this.value');
  html += '</div>';
  if (d.legendaryActionBudget > 0 || d.legendaryActions.length > 0) {
    html += '<div style="margin-top:0.5rem">';
    if (d.legendaryActions.length > 0) {
      html += '<div class="dyn-header">';
      html += '<span class="dyn-label" style="flex:2">Name</span>';
      html += '<span class="dyn-label" style="width:55px">Cost</span>';
      html += '<span style="width:30px"></span>';
      html += '</div>';
    }
    d.legendaryActions.forEach((la, i) => {
      html += '<div class="dyn-row" style="flex-direction:column">';
      html += '<div style="display:flex;gap:0.4rem;width:100%">';
      html += '<input type="text" value="' + esc(la.name) + '" onchange="formData.legendaryActions[' + i + '].name=this.value" placeholder="Action name" style="flex:2">';
      html += '<input type="number" value="' + la.cost + '" onchange="formData.legendaryActions[' + i + '].cost=+this.value" placeholder="#" style="width:55px">';
      html += '<button class="btn-remove" onclick="formData.legendaryActions.splice(' + i + ',1);renderTemplateForm()">×</button>';
      html += '</div>';
      html += '<textarea onchange="formData.legendaryActions[' + i + '].desc=this.value" placeholder="Description..." style="width:100%">' + esc(la.desc) + '</textarea>';
      html += '</div>';
    });
    html += '<button class="btn-add-row" onclick="formData.legendaryActions.push({name:\'\',cost:1,desc:\'\'});renderTemplateForm()">+ Add Legendary Action</button>';
    html += '</div>';
  }
  html += '</div>';

  // ── Tactics ──
  html += '<div class="form-section"><div class="form-section-title">Tactics & Notes</div>';
  html += '<div class="form-field"><textarea rows="3" onchange="formData.tactics=this.value" placeholder="How this monster fights: target priority, positioning, retreat conditions...">' + esc(d.tactics) + '</textarea>';
  html += '</div></div>';

  // ── Form Actions ──
  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="saveTemplate()">Save</button>';
  html += '<button onclick="closeTemplateForm()">Close</button>';
  html += '<button class="btn-danger" onclick="cancelTemplateForm()">Cancel</button>';
  html += '</div>';

  el.innerHTML = html;
  el.scrollTop = 0;
}

function formField(label, type, value, onchange, placeholder, options) {
  let html = '<div class="form-field"><label>' + esc(label) + '</label>';
  if (type === 'select') {
    html += '<select onchange="' + onchange + '">';
    (options || []).forEach(opt => {
      html += '<option value="' + esc(opt) + '"' + (value === opt ? ' selected' : '') + '>' + esc(opt) + '</option>';
    });
    html += '</select>';
  } else if (type === 'number') {
    html += '<input type="number" value="' + (value ?? '') + '" onchange="' + onchange + '"' + (placeholder ? ' placeholder="' + esc(placeholder) + '"' : '') + '>';
  } else {
    html += '<input type="text" value="' + esc(value || '') + '" onchange="' + onchange + '"' + (placeholder ? ' placeholder="' + esc(placeholder) + '"' : '') + '>';
  }
  html += '</div>';
  return html;
}

function hpFromFormula(mode) {
  const formula = formData.hpFormula.trim();
  if (!formula) { setStatus('Enter an HP formula first.', 'warning'); return; }
  const match = formula.match(/^(\d+)d(\d+)\s*([+-]\s*\d+)?$/i);
  if (!match) { setStatus('Invalid formula: ' + formula, 'error'); return; }
  const count = parseInt(match[1]);
  const sides = parseInt(match[2]);
  const modifier = match[3] ? parseInt(match[3].replace(/\s/g, '')) : 0;

  if (mode === 'avg') {
    const avg = Math.floor(count * (sides + 1) / 2) + modifier;
    formData.hpMax = Math.max(1, avg);
    setStatus('HP set to average: ' + formData.hpMax, 'success');
  } else {
    const result = rollDice(formula);
    formData.hpMax = Math.max(1, result.total);
    setStatus('HP rolled: ' + result.text, 'success');
  }
  renderTemplateForm();
}

function saveTemplate() {
  if (!formData.name.trim()) {
    setStatus('Monster name is required.', 'error');
    return;
  }
  const idx = state.templates.findIndex(t => t.id === formData.id);
  if (idx >= 0) {
    state.templates[idx] = deepClone(formData);
    setStatus('Monster saved: ' + formData.name, 'success');
  } else {
    state.templates.push(deepClone(formData));
    setStatus('Monster saved: ' + formData.name, 'success');
  }
  save('templates');
  savedFormSnapshot = deepClone(formData);
}

function closeTemplateForm() {
  if (isFormDirty()) {
    if (!confirm('You have unsaved changes. Close without saving?')) return;
  }
  formMode = null;
  formData = null;
  savedFormSnapshot = null;
  setStatus('', '');
  render();
}

function cancelTemplateForm() {
  if (isFormDirty()) {
    if (!confirm('Discard all changes?')) return;
  }
  formMode = null;
  formData = null;
  savedFormSnapshot = null;
  setStatus('', '');
  render();
}

function deleteTemplate(id) {
  const t = state.templates.find(t => t.id === id);
  if (!t) return;
  if (!confirm('Delete "' + t.name + '"? This cannot be undone.')) return;
  state.templates = state.templates.filter(t => t.id !== id);
  save('templates');
  setStatus('Deleted: ' + t.name, 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Encounter List ──
// ═══════════════════════════════════════════════════════════════

function renderEncounterList() {
  const el = document.getElementById('viewEncounters');
  document.getElementById('btnNew').style.display = '';

  const filtered = state.encounters.filter(e =>
    !searchQuery || e.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (e.campaign && e.campaign.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  let html = '<div class="search-bar"><input type="text" placeholder="Search encounters..." value="' + esc(searchQuery) + '" oninput="searchQuery=this.value;renderEncounterList()"></div>';

  if (filtered.length === 0) {
    if (state.encounters.length === 0) {
      html += '<div class="empty-state"><p>No encounters yet.</p><p>Click <strong>+ New Encounter</strong> to build one.</p></div>';
    } else {
      html += '<div class="empty-state"><p>No encounters match your search.</p></div>';
    }
  } else {
    filtered.forEach(e => {
      const meta = [];
      if (e.campaign) meta.push(e.campaign);
      if (e.location) meta.push(e.location);
      const totalMonsters = e.monsters.reduce((sum, m) => sum + m.qty, 0);
      if (totalMonsters) meta.push(totalMonsters + ' monster' + (totalMonsters > 1 ? 's' : ''));

      html += '<div class="card">';
      html += '<div class="card-header">';
      html += '<span class="card-title">' + esc(e.name || 'Unnamed') + '</span>';
      html += '<div class="card-actions">';
      html += '<button class="btn-sm btn-action" onclick="startCombat(\'' + e.id + '\')" title="Start combat">Combat</button>';
      html += '<button class="btn-sm" onclick="showEncounterForm(\'' + e.id + '\')">Edit</button>';
      html += '<button class="btn-sm btn-danger" onclick="deleteEncounter(\'' + e.id + '\')">Delete</button>';
      html += '</div></div>';
      html += '<div class="card-meta">' + meta.map(m => '<span>' + esc(m) + '</span>').join('') + '</div>';
      html += '</div>';
    });
  }

  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Encounter Form ──
// ═══════════════════════════════════════════════════════════════

function showEncounterForm(id) {
  formMode = 'encounter';
  if (id) {
    const e = state.encounters.find(e => e.id === id);
    if (!e) { setStatus('Encounter not found.', 'error'); return; }
    formData = deepClone(e);
  } else {
    formData = newEncounter();
  }
  savedFormSnapshot = deepClone(formData);
  document.getElementById('btnNew').style.display = 'none';
  renderEncounterForm();
}

function renderEncounterForm() {
  const d = formData;
  const el = document.getElementById('viewEncounters');

  let html = '';

  // ── Details ──
  html += '<div class="form-section"><div class="form-section-title">Encounter Details</div>';
  html += '<div class="form-grid cols-3">';
  html += formField('Name *', 'text', d.name, 'formData.name=this.value', 'Ambush at Cragmaw');
  html += formField('Campaign', 'text', d.campaign, 'formData.campaign=this.value', 'Lost Mines');
  html += formField('Location', 'text', d.location, 'formData.location=this.value', 'Forest Road');
  html += '</div>';
  html += '<div style="margin-top:0.5rem">';
  html += '<div class="form-field"><label>Notes</label>';
  html += '<textarea onchange="formData.notes=this.value" placeholder="Encounter notes...">' + esc(d.notes) + '</textarea>';
  html += '</div></div></div>';

  // ── Monsters ──
  html += '<div class="form-section"><div class="form-section-title">Monsters</div>';
  if (state.templates.length === 0) {
    html += '<p style="font-size:0.8rem;color:var(--text-dim)">No monsters yet. Create some in the Monsters tab first.</p>';
  } else {
    html += '<div style="display:flex;gap:0.4rem;margin-bottom:0.5rem;align-items:flex-start">';
    html += '<div class="search-select">';
    html += '<input type="text" id="monsterPicker" placeholder="Search monsters..." autocomplete="off" oninput="filterMonsterPicker(this.value)" onfocus="filterMonsterPicker(this.value)" style="width:100%;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem;box-sizing:border-box">';
    html += '<div id="monsterPickerDropdown" class="search-dropdown"></div>';
    html += '</div>';
    html += '<input type="number" id="monsterQty" value="1" min="1" max="20" style="width:55px;padding:0.4rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem;font-family:var(--mono);text-align:center">';
    html += '<button class="btn-sm" onclick="addMonsterToEncounter()">Add</button>';
    html += '</div>';
  }
  d.monsters.forEach((m, i) => {
    const t = state.templates.find(t => t.id === m.templateId);
    html += '<div class="monster-pick">';
    html += '<span class="pick-name">' + esc(t ? t.name : '(deleted template)') + '</span>';
    html += '<input type="number" class="pick-qty" value="' + m.qty + '" min="1" max="20" onchange="formData.monsters[' + i + '].qty=+this.value">';
    html += '<button class="btn-sm btn-remove" onclick="formData.monsters.splice(' + i + ',1);renderEncounterForm()">×</button>';
    html += '</div>';
  });
  html += '</div>';

  // ── Form Actions ──
  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="saveEncounter()">Save</button>';
  html += '<button onclick="closeEncounterForm()">Close</button>';
  html += '<button class="btn-danger" onclick="cancelEncounterForm()">Cancel</button>';
  html += '</div>';

  el.innerHTML = html;
  el.scrollTop = 0;
}

function addMonsterToEncounter() {
  const input = document.getElementById('monsterPicker');
  const qtyInput = document.getElementById('monsterQty');
  if (!input) return;
  const templateId = input.dataset.templateId;
  if (!templateId) { setStatus('Select a monster first.', 'warning'); return; }
  const qty = Math.max(1, parseInt(qtyInput.value) || 1);

  // Check if already added — increment qty instead
  const existing = formData.monsters.find(m => m.templateId === templateId);
  if (existing) {
    existing.qty += qty;
  } else {
    formData.monsters.push({ templateId, qty });
  }
  input.value = '';
  input.dataset.templateId = '';
  renderEncounterForm();
}

function filterMonsterPicker(query) {
  const dropdown = document.getElementById('monsterPickerDropdown');
  if (!dropdown) return;
  const q = query.toLowerCase();
  const matches = state.templates.filter(t => t.name.toLowerCase().includes(q));
  if (matches.length === 0) {
    dropdown.innerHTML = '<div class="search-dropdown-item" style="color:var(--text-dim);cursor:default">No matches</div>';
  } else {
    dropdown.innerHTML = matches.map(t =>
      '<div class="search-dropdown-item" onmousedown="selectMonster(\'' + t.id + '\')">' + esc(t.name) + '<span class="cr-tag">CR ' + esc(t.cr || '?') + '</span></div>'
    ).join('');
  }
  dropdown.classList.add('open');
}

function selectMonster(templateId) {
  const input = document.getElementById('monsterPicker');
  const dropdown = document.getElementById('monsterPickerDropdown');
  const t = state.templates.find(t => t.id === templateId);
  if (!input || !t) return;
  input.value = t.name;
  input.dataset.templateId = templateId;
  if (dropdown) dropdown.classList.remove('open');
}

document.addEventListener('click', function(e) {
  const dropdown = document.getElementById('monsterPickerDropdown');
  if (dropdown && !e.target.closest('.search-select')) dropdown.classList.remove('open');
});

function saveEncounter() {
  if (!formData.name.trim()) {
    setStatus('Encounter name is required.', 'error');
    return;
  }
  const idx = state.encounters.findIndex(e => e.id === formData.id);
  if (idx >= 0) {
    state.encounters[idx] = deepClone(formData);
    setStatus('Encounter saved: ' + formData.name, 'success');
  } else {
    state.encounters.push(deepClone(formData));
    setStatus('Encounter saved: ' + formData.name, 'success');
  }
  save('encounters');
  savedFormSnapshot = deepClone(formData);
}

function closeEncounterForm() {
  if (isFormDirty()) {
    if (!confirm('You have unsaved changes. Close without saving?')) return;
  }
  formMode = null;
  formData = null;
  savedFormSnapshot = null;
  setStatus('', '');
  render();
}

function cancelEncounterForm() {
  if (isFormDirty()) {
    if (!confirm('Discard all changes?')) return;
  }
  formMode = null;
  formData = null;
  savedFormSnapshot = null;
  setStatus('', '');
  render();
}

function deleteEncounter(id) {
  const e = state.encounters.find(e => e.id === id);
  if (!e) return;
  if (!confirm('Delete encounter "' + e.name + '"?')) return;
  state.encounters = state.encounters.filter(e => e.id !== id);
  save('encounters');
  const hadCombats = state.combats.length;
  state.combats = state.combats.filter(c => c.encounterId !== id);
  if (state.combats.length !== hadCombats) {
    activeCombatId = null;
    pendingCombatEncounterId = null;
    saveCombat();
  }
  setStatus('Deleted: ' + e.name, 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Party List ──
// ═══════════════════════════════════════════════════════════════

function renderPartyList() {
  const el = document.getElementById('viewParties');
  document.getElementById('btnNew').style.display = '';

  let html = '';

  if (state.parties.length === 0) {
    html += '<div class="empty-state"><p>No parties yet.</p><p>Click <strong>+ New Party</strong> to create one.</p></div>';
  } else {
    state.parties.forEach(p => {
      html += '<div class="card">';
      html += '<div class="card-header">';
      html += '<span class="card-title">' + esc(p.name || 'Unnamed') + '</span>';
      html += '<div class="card-actions">';
      html += '<button class="btn-sm" onclick="showPartyForm(\'' + p.id + '\')">Edit</button>';
      html += '<button class="btn-sm btn-danger" onclick="deleteParty(\'' + p.id + '\')">Delete</button>';
      html += '</div></div>';
      html += '<div class="card-meta"><span>' + p.players.length + ' player' + (p.players.length !== 1 ? 's' : '') + '</span>';
      if (p.players.length > 0) html += '<span>' + p.players.map(n => esc(n)).join(', ') + '</span>';
      html += '</div>';
      html += '</div>';
    });
  }

  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Party Form ──
// ═══════════════════════════════════════════════════════════════

function showPartyForm(id) {
  formMode = 'party';
  if (id) {
    const p = state.parties.find(p => p.id === id);
    if (!p) { setStatus('Party not found.', 'error'); return; }
    formData = deepClone(p);
  } else {
    formData = newParty();
  }
  savedFormSnapshot = deepClone(formData);
  document.getElementById('btnNew').style.display = 'none';
  renderPartyForm();
}

function renderPartyForm() {
  const d = formData;
  const el = document.getElementById('viewParties');

  let html = '';

  html += '<div class="form-section"><div class="form-section-title">Party Details</div>';
  html += '<div class="form-grid cols-2">';
  html += formField('Party Name *', 'text', d.name, 'formData.name=this.value', 'Tuesday Night Crew');
  html += '<div class="form-field"></div>';
  html += '</div></div>';

  // ── Players ──
  html += '<div class="form-section"><div class="form-section-title">Players</div>';
  html += '<div style="display:flex;gap:0.4rem;margin-bottom:0.5rem">';
  html += '<input type="text" id="newPlayerInput" placeholder="Player name" style="flex:1;padding:0.4rem 0.6rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.8rem" onkeydown="if(event.key===\'Enter\')addPlayerToParty()">';
  html += '<button class="btn-sm" onclick="addPlayerToParty()">Add</button>';
  html += '</div>';

  if (d.players.length > 0) {
    html += '<div class="player-list">';
    d.players.forEach((p, idx) => {
      html += '<span class="player-chip">';
      html += esc(p);
      html += '<span class="chip-remove" onclick="removePlayerFromParty(' + idx + ')" title="Remove player">×</span>';
      html += '</span>';
    });
    html += '</div>';
  }
  html += '</div>';

  // ── Form Actions ──
  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="saveParty()">Save</button>';
  html += '<button onclick="closePartyForm()">Close</button>';
  html += '<button class="btn-danger" onclick="cancelPartyForm()">Cancel</button>';
  html += '</div>';

  el.innerHTML = html;
  el.scrollTop = 0;
}

function addPlayerToParty() {
  const input = document.getElementById('newPlayerInput');
  if (!input) return;
  const name = input.value.trim();
  if (!name) return;
  if (!formData.players.includes(name)) formData.players.push(name);
  renderPartyForm();
}

function removePlayerFromParty(idx) {
  formData.players.splice(idx, 1);
  renderPartyForm();
}

function saveParty() {
  if (!formData.name.trim()) {
    setStatus('Party name is required.', 'error');
    return;
  }
  const idx = state.parties.findIndex(p => p.id === formData.id);
  if (idx >= 0) {
    state.parties[idx] = deepClone(formData);
    setStatus('Party saved: ' + formData.name, 'success');
  } else {
    state.parties.push(deepClone(formData));
    setStatus('Party saved: ' + formData.name, 'success');
  }
  save('parties');
  savedFormSnapshot = deepClone(formData);
}

function closePartyForm() {
  if (isFormDirty()) {
    if (!confirm('You have unsaved changes. Close without saving?')) return;
  }
  formMode = null;
  formData = null;
  savedFormSnapshot = null;
  setStatus('', '');
  render();
}

function cancelPartyForm() {
  if (isFormDirty()) {
    if (!confirm('Discard all changes?')) return;
  }
  formMode = null;
  formData = null;
  savedFormSnapshot = null;
  setStatus('', '');
  render();
}

function deleteParty(id) {
  const p = state.parties.find(p => p.id === id);
  if (!p) return;
  if (!confirm('Delete party "' + p.name + '"?')) return;
  state.parties = state.parties.filter(p => p.id !== id);
  save('parties');
  setStatus('Deleted: ' + p.name, 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Combat View (Phase 2 placeholder) ──
// ═══════════════════════════════════════════════════════════════

function renderCombatView() {
  const el = document.getElementById('viewCombat');

  // Active combat selected?
  const active = getActiveCombat();
  if (active && active.active) {
    if (active.round === 0) {
      renderInitiativeSetup(el);
    } else {
      renderActiveCombat(el);
    }
    return;
  }

  // Starting a new combat?
  if (pendingCombatEncounterId) {
    el.innerHTML = renderCombatPartySelect();
    return;
  }

  // Have existing combats? Show combat list
  if (state.combats.length > 0) {
    renderCombatList(el);
    return;
  }

  el.innerHTML = '<div class="empty-state"><p>No active combats.</p><p>Go to <strong>Encounters</strong> and click <strong>Combat</strong> to start one.</p></div>';
}

function renderCombatList(el) {
  let html = '<div class="form-section">';
  html += '<div class="form-section-title">Active Combats</div>';
  state.combats.forEach(combat => {
    const enc = state.encounters.find(e => e.id === combat.encounterId);
    const currentName = combat.combatants[combat.turnIndex] ? combat.combatants[combat.turnIndex].name : '—';
    const alive = combat.combatants.filter(c => !c.dead).length;
    html += '<div class="combat-list-card" onclick="resumeCombat(\'' + combat.id + '\')">';
    html += '<div class="combat-list-name">' + esc(combat.name || (enc ? enc.name : 'Combat')) + '</div>';
    html += '<div class="combat-list-info">';
    if (combat.round === 0) {
      html += '<span class="round-badge" style="font-size:0.65rem;padding:0.15rem 0.4rem">Setup</span>';
    } else {
      html += '<span class="round-badge" style="font-size:0.65rem;padding:0.15rem 0.4rem">Round ' + combat.round + '</span>';
      html += '<span style="font-size:0.75rem;color:var(--text-dim)">Turn: ' + esc(currentName) + '</span>';
    }
    html += '<span style="font-size:0.75rem;color:var(--text-dim)">' + alive + '/' + combat.combatants.length + ' alive</span>';
    html += '</div>';
    const players = combat.combatants.filter(c => c.type === 'player');
    if (players.length > 0) {
      html += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.25rem">' + players.map(p => esc(p.name)).join(', ') + '</div>';
    }
    html += '</div>';
  });
  html += '</div>';
  el.innerHTML = html;
}

function resumeCombat(combatId) {
  activeCombatId = combatId;
  render();
}

let pendingCombatEncounterId = null;

function startCombat(encounterId) {
  const enc = state.encounters.find(e => e.id === encounterId);
  if (!enc) { setStatus('Encounter not found.', 'error'); return; }
  if (enc.monsters.length === 0) {
    setStatus('Add monsters to the encounter first.', 'warning');
    return;
  }
  if (state.parties.length === 0) {
    setStatus('Create a party in the Parties tab first.', 'warning');
    return;
  }
  pendingCombatEncounterId = encounterId;
  activeCombatId = null;
  switchView('combat');
}

function renderCombatPartySelect() {
  const enc = state.encounters.find(e => e.id === pendingCombatEncounterId);
  if (!enc) return '<div class="empty-state"><p>Encounter not found.</p></div>';

  let html = '<div class="form-section"><div class="form-section-title">Start Combat: ' + esc(enc.name) + '</div>';
  const totalMonsters = enc.monsters.reduce((sum, m) => sum + m.qty, 0);
  html += '<p style="font-size:0.8rem;color:var(--text-muted);margin-bottom:1rem">' + totalMonsters + ' monster' + (totalMonsters > 1 ? 's' : '') + (enc.location ? ' at ' + esc(enc.location) : '') + '</p>';
  html += '<div class="form-section-title">Select Party</div>';

  state.parties.forEach(p => {
    html += '<div class="card" style="cursor:pointer" onclick="launchCombat(\'' + p.id + '\')">';
    html += '<div class="card-header">';
    html += '<span class="card-title">' + esc(p.name || 'Unnamed') + '</span>';
    html += '<button class="btn-sm btn-action">Select</button>';
    html += '</div>';
    html += '<div class="card-meta"><span>' + p.players.length + ' player' + (p.players.length !== 1 ? 's' : '') + '</span><span>' + esc(p.players.join(', ')) + '</span></div>';
    html += '</div>';
  });

  html += '<div style="margin-top:1rem"><button onclick="pendingCombatEncounterId=null;render()">Cancel</button></div>';
  html += '</div>';
  return html;
}

function launchCombat(partyId) {
  const party = state.parties.find(p => p.id === partyId);
  const enc = state.encounters.find(e => e.id === pendingCombatEncounterId);
  if (!party || !enc) { setStatus('Party or encounter not found.', 'error'); return; }

  const combatants = [];

  // Pre-count per templateId for numbering across duplicate entries
  const templateCounts = {};
  enc.monsters.forEach(m => {
    templateCounts[m.templateId] = (templateCounts[m.templateId] || 0) + m.qty;
  });
  const templateCounters = {};

  // Create monster instances
  enc.monsters.forEach(m => {
    const template = state.templates.find(t => t.id === m.templateId);
    if (!template) return;
    const total = templateCounts[m.templateId];
    if (!templateCounters[m.templateId]) templateCounters[m.templateId] = 0;

    for (let i = 0; i < m.qty; i++) {
      templateCounters[m.templateId]++;
      const num = templateCounters[m.templateId];
      const name = total > 1 ? template.name + ' ' + num : template.name;

      const bonus = template.initBonus;
      const notation = '1d20' + (bonus >= 0 ? '+' + bonus : String(bonus));
      const initRoll = rollDice(notation, { advantage: template.initAdvantage });
      const init = initRoll.total;

      combatants.push({
        id: uuid(),
        templateId: template.id,
        name: name,
        type: 'monster',
        init: init,
        initRollText: initRoll.text,
        currentHp: template.hpMax
      });
    }
  });

  // Create player instances
  party.players.forEach(name => {
    combatants.push({
      id: uuid(),
      name: name,
      type: 'player',
      init: 0
    });
  });

  const newCombat = {
    id: uuid(),
    name: enc.name + ' \u2014 ' + party.name,
    encounterId: enc.id,
    partyId: party.id,
    round: 0,
    turnIndex: 0,
    combatants: combatants,
    damageLog: [],
    active: true
  };
  state.combats.push(newCombat);
  activeCombatId = newCombat.id;

  pendingCombatEncounterId = null;
  saveCombat();
  setStatus('Rolling initiative for ' + enc.name + '...', 'success');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Initiative Setup ──
// ═══════════════════════════════════════════════════════════════

function renderInitiativeSetup(el) {
  const combat = getActiveCombat();
  const enc = state.encounters.find(e => e.id === combat.encounterId);

  let html = '<div class="form-section">';
  html += '<div class="form-section-title">Initiative Setup' + (enc ? ': ' + esc(enc.name) : '') + '</div>';
  html += '<p style="font-size:0.78rem;color:var(--text-muted);margin-bottom:0.75rem">Enter player initiatives. Monster initiatives are pre-rolled but editable.</p>';

  // Sort for display: monsters first (already have init), then players
  const sorted = [...combat.combatants].sort((a, b) => {
    if (a.type === 'player' && b.type !== 'player') return 1;
    if (a.type !== 'player' && b.type === 'player') return -1;
    return (b.init ?? -Infinity) - (a.init ?? -Infinity);
  });

  sorted.forEach(c => {
    const idx = combat.combatants.indexOf(c);
    const typeLabel = c.type === 'player' ? 'Player' : c.type === 'adhoc' ? 'Other' : 'Monster';
    const typeColor = c.type === 'player' ? 'var(--success)' : c.type === 'adhoc' ? 'var(--warning)' : 'var(--text-dim)';
    html += '<div class="init-setup-row">';
    html += '<span style="font-size:0.65rem;color:' + typeColor + ';text-transform:uppercase;font-weight:600">' + typeLabel + '</span>';
    html += '<span style="font-size:0.85rem;font-weight:600">' + esc(c.name) + '</span>';
    html += '<span style="font-family:var(--mono);font-size:0.7rem;color:var(--text-dim);text-align:right">' + (c.initRollText ? esc(c.initRollText) : '') + '</span>';
    html += '<input type="number" value="' + (c.init !== null && c.init !== undefined ? c.init : '') + '" step="0.01" onchange="setCombatantInit(' + idx + ',this.value)" placeholder="Init">';
    html += '</div>';
  });

  html += '<div style="margin-top:0.75rem;display:flex;gap:0.5rem">';
  html += '<button class="btn-sm" onclick="addAdhocCombatant()">+ Add Combatant</button>';
  html += '</div>';

  html += '<div class="form-actions">';
  html += '<button class="btn-action" onclick="beginCombat()">Begin Combat</button>';
  html += '<button class="btn-danger" onclick="endCombat()">Cancel</button>';
  html += '</div>';
  html += '</div>';

  el.innerHTML = html;
}

function setCombatantInit(idx, value) {
  getActiveCombat().combatants[idx].init = value === '' ? null : +value;
  saveCombat();
}

function addAdhocCombatant() {
  const name = prompt('Combatant name (e.g., "Lair Action", "Reinforcements"):');
  if (!name || !name.trim()) return;
  const combat = getActiveCombat();
  combat.combatants.push({
    id: uuid(),
    name: name.trim(),
    type: 'adhoc',
    init: 20.0,
    notes: ''
  });
  if (combat.round >= 1) {
    const currentId = combat.combatants[combat.turnIndex].id;
    combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
    combat.turnIndex = combat.combatants.findIndex(c => c.id === currentId);
    if (combat.turnIndex < 0) combat.turnIndex = 0;
  }
  saveCombat();
  render();
}

function beginCombat() {
  const combat = getActiveCombat();
  const missing = combat.combatants.filter(c => c.type === 'player' && (c.init === null || c.init === undefined));
  if (missing.length > 0) {
    setStatus('Enter initiative for: ' + missing.map(c => c.name).join(', '), 'error');
    return;
  }
  combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
  combat.round = 1;
  combat.turnIndex = 0;
  combat.combatants.forEach(c => { c.reactionUsed = false; });
  saveCombat();
  setStatus('Round 1 — ' + combat.combatants[0].name + '\'s turn', 'success');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Active Combat ──
// ═══════════════════════════════════════════════════════════════

function renderActiveCombat(el) {
  const combat = getActiveCombat();
  let html = '';

  // ── Combat Bar ──
  html += '<div class="combat-bar">';
  if (state.combats.length > 1) {
    html += '<button class="btn-sm" onclick="activeCombatId=null;render()" title="Back to combat list">&laquo; List</button>';
  }
  html += '<span class="round-badge">Round ' + combat.round + '</span>';
  html += '<button class="btn-sm" onclick="prevTurn()">&laquo; Prev</button>';
  html += '<button class="btn-sm btn-action" onclick="nextTurn()">Next &raquo;</button>';
  html += '<div class="spacer"></div>';
  html += '<button class="btn-sm" onclick="addAdhocCombatant()">+ Add</button>';
  html += '<button class="btn-sm btn-danger" onclick="endCombat()">End Combat</button>';
  html += '</div>';

  // ── Column Headers ──
  html += '<div class="combatant-row" style="border:none;background:none;cursor:default;padding:0.2rem 0.75rem;margin-bottom:0;min-height:0">';
  html += '<span class="ac-val" style="font-size:0.6rem;text-transform:uppercase;letter-spacing:0.05em">Init</span>';
  html += '<span style="font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.05em">Name</span>';
  html += '<span class="ac-val" style="font-size:0.6rem;text-transform:uppercase;letter-spacing:0.05em">AC</span>';
  html += '<span style="font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.05em">HP</span>';
  html += '<span style="font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.05em;text-align:center">R</span>';
  html += '</div>';

  // ── Combatant Rows ──
  combat.combatants.forEach((c, idx) => {
    const isCurrent = idx === combat.turnIndex;
    const isDead = c.dead || false;
    const template = getTemplate(c);

    let rowClasses = 'combatant-row';
    if (isCurrent) rowClasses += ' current-turn';
    if (isDead) rowClasses += ' is-dead';

    html += '<div class="' + rowClasses + '" onclick="toggleCombatantDetail(' + idx + ')">';

    // Init
    html += '<span class="init-val">' + (c.init !== null && c.init !== undefined ? Math.floor(c.init) : '–') + '</span>';

    // Name + badges
    html += '<span class="combatant-name type-' + c.type + '">' + esc(c.name);
    if (c.type === 'monster' && template) {
      if (template.legendaryActionBudget > 0) {
        const laRemaining = c.legendaryActionsRemaining !== undefined ? c.legendaryActionsRemaining : template.legendaryActionBudget;
        html += '<span class="la-badge">LA:' + laRemaining + '/' + template.legendaryActionBudget + '</span>';
      }
      if (template.legendaryResistances > 0) {
        const lrRemaining = c.legendaryResistancesRemaining !== undefined ? c.legendaryResistancesRemaining : template.legendaryResistances;
        html += '<span class="lr-badge">LR:' + lrRemaining + '/' + template.legendaryResistances + '</span>';
      }
    }
    // Condition chips (all combatant types)
    if (c.conditions && c.conditions.length > 0) {
      c.conditions.forEach(cond => {
        html += '<span class="condition-chip' + (cond.durationType === 'save' ? ' save-based' : '') + '">' + esc(cond.name);
        if (cond.durationType === 'rounds' && cond.duration) html += ' (' + cond.duration + ')';
        html += '</span>';
      });
    }
    if (c.concentration) {
      html += '<span class="concentration-chip">Conc: ' + esc(c.concentration) + '</span>';
    }
    // Turn-start notification badge (visible when panel closed)
    if (isCurrent && c.rollLog && c.rollLog.length > 0 && !c._expanded) {
      html += '<span class="turn-notify">' + c.rollLog.length + ' alert' + (c.rollLog.length !== 1 ? 's' : '') + '</span>';
    }
    html += '</span>';

    // AC
    if (c.type === 'monster' && template) {
      html += '<span class="ac-val">' + resolveField(c, 'ac') + '</span>';
    } else if (c.type === 'player' && c.ac) {
      html += '<span class="ac-val">' + c.ac + '</span>';
    } else {
      html += '<span class="ac-val"></span>';
    }

    // HP bar (monsters only)
    if (c.type === 'monster' && template) {
      const maxHp = resolveField(c, 'hpMax');
      const curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
      const tempHp = c.tempHp || 0;
      const pct = maxHp > 0 ? Math.max(0, Math.min(100, Math.round((curHp / maxHp) * 100))) : 0;
      const hpClass = pct > 50 ? 'hp-high' : pct > 25 ? 'hp-mid' : 'hp-low';
      html += '<div class="hp-bar-container">';
      html += '<div class="hp-bar-fill ' + hpClass + '" style="width:' + pct + '%"></div>';
      html += '<span class="hp-bar-text">' + curHp + (tempHp > 0 ? '+' + tempHp : '') + '/' + maxHp + '</span>';
      html += '</div>';
    } else {
      html += '<span></span>';
    }

    // Reaction indicator
    if (c.type !== 'adhoc') {
      const rUsed = c.reactionUsed || false;
      html += '<span class="reaction-indicator ' + (rUsed ? 'used' : 'available') + '" onclick="event.stopPropagation();toggleReaction(' + idx + ')" title="' + (rUsed ? 'Reaction used' : 'Reaction available') + '">R</span>';
    } else {
      html += '<span></span>';
    }

    html += '</div>';

    // ── Detail Panel ──
    const expanded = c._expanded || false;
    html += '<div class="combatant-detail' + (expanded ? ' expanded' : '') + '" id="detail-' + idx + '">';
    html += renderCombatantDetail(c, idx, template);
    html += '</div>';
  });

  el.innerHTML = html;
}

function renderCombatantDetail(c, idx, template) {
  let html = '<div class="detail-grid">';

  if (c.type === 'monster' && template) {
    // Left column: HP + Attacks
    html += '<div>';

    // HP Controls
    const maxHp = resolveField(c, 'hpMax');
    const curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
    const tempHp = c.tempHp || 0;
    html += '<div class="detail-section-title">Hit Points</div>';
    html += '<div style="font-family:var(--mono);font-size:0.82rem;margin-bottom:0.3rem">';
    html += '<strong>' + curHp + '</strong> / ' + maxHp;
    if (tempHp > 0) html += ' <span style="color:var(--accent)">(+' + tempHp + ' temp)</span>';
    html += '</div>';
    html += '<div class="hp-controls">';
    html += '<input type="number" id="hpInput-' + idx + '" placeholder="0" min="0" onclick="event.stopPropagation()">';
    html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();applyDamage(' + idx + ')">Dmg</button>';
    html += '<button class="btn-sm btn-success" onclick="event.stopPropagation();applyHeal(' + idx + ')">Heal</button>';
    html += '<button class="btn-sm btn-warning" onclick="event.stopPropagation();applyTempHp(' + idx + ')">THP</button>';
    html += '</div>';

    // Multiattack
    if (template.multiattack) {
      html += '<div class="multiattack-box">Multiattack: ' + esc(template.multiattack) + '</div>';
    }

    // Attacks
    if (template.attacks.length > 0) {
      html += '<div class="detail-section-title" style="margin-top:0.5rem">Attacks</div>';
      template.attacks.forEach((atk, atkIdx) => {
        html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
        html += '<div style="display:flex;align-items:center;gap:0.4rem;flex-wrap:wrap">';
        html += '<strong style="font-size:0.8rem">' + esc(atk.name) + '</strong>';
        html += '<span style="font-family:var(--mono);font-size:0.72rem;color:var(--text-dim)">';
        html += (atk.bonus >= 0 ? '+' : '') + atk.bonus + ' to hit';
        if (atk.note) html += ' &middot; ' + esc(atk.note);
        html += '</span>';
        html += '<div class="spacer"></div>';
        html += '<button class="btn-sm" onclick="event.stopPropagation();rollAttack(' + idx + ',' + atkIdx + ')">Atk</button>';
        html += '<button class="btn-sm btn-success" onclick="event.stopPropagation();rollAttack(' + idx + ',' + atkIdx + ',\'advantage\')">Adv</button>';
        html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();rollAttack(' + idx + ',' + atkIdx + ',\'disadvantage\')">Dis</button>';
        if (atk.damages && atk.damages.length > 0) {
          html += '<button class="btn-sm" onclick="event.stopPropagation();rollDamageForAttack(' + idx + ',' + atkIdx + ')">Dmg</button>';
          html += '<button class="btn-sm btn-success" onclick="event.stopPropagation();rollDamageForAttack(' + idx + ',' + atkIdx + ',true)">Crit</button>';
        }
        html += '</div>';
        // Damage summary
        if (atk.damages && atk.damages.length > 0) {
          html += '<div style="font-size:0.72rem;color:var(--text-dim);margin-top:0.15rem">';
          html += atk.damages.map(dm => esc(dm.dice) + ' ' + esc(dm.type) + (dm.note ? ' (' + esc(dm.note) + ')' : '')).join(' + ');
          html += '</div>';
        }
        html += '</div>';
      });
    }

    // Roll log
    html += '<div id="rollLog-' + idx + '">';
    if (c.rollLog && c.rollLog.length > 0) {
      html += '<div class="roll-log">';
      c.rollLog.forEach(entry => {
        html += '<div class="roll-log-entry ' + (entry.cssClass || '') + '">';
        html += '<strong>' + entry.label + ':</strong> ' + entry.text;
        html += '</div>';
      });
      html += '</div>';
    }
    html += '</div>';

    html += '</div>';

    // Right column: Stats summary
    html += '<div>';
    html += '<div class="detail-section-title">Stats</div>';
    html += '<div style="font-size:0.72rem;color:var(--text-muted);display:grid;grid-template-columns:repeat(2,1fr);gap:0.15rem 0.5rem">';
    ABILITIES.forEach(ab => {
      html += '<div style="display:flex;align-items:center;gap:0.3rem">';
      html += '<span style="min-width:4.5em">' + ab.toUpperCase() + ' ' + template.abilities[ab] + ' (' + modStr(template.abilities[ab]) + ')</span>';
      html += '<button class="btn-sm" style="font-size:0.6rem;padding:0.05rem 0.25rem" onclick="event.stopPropagation();rollAbilityCheck(' + idx + ',\'' + ab + '\')">Chk</button>';
      html += '<button class="btn-sm" style="font-size:0.6rem;padding:0.05rem 0.25rem" onclick="event.stopPropagation();rollSavingThrow(' + idx + ',\'' + ab + '\')">Save</button>';
      html += '</div>';
    });
    html += '</div>';

    // Speed, senses
    html += '<div style="font-size:0.72rem;color:var(--text-dim);margin-top:0.3rem">';
    if (template.speed) html += 'Speed: ' + esc(template.speed) + '<br>';
    if (template.senses) html += 'Senses: ' + esc(template.senses) + '<br>';
    html += '</div>';

    // Features
    if (template.features.length > 0) {
      html += '<div class="detail-section-title" style="margin-top:0.5rem">Features</div>';
      template.features.forEach((f, fIdx) => {
        html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
        html += '<div style="font-size:0.75rem;display:flex;align-items:center;gap:0.4rem;flex-wrap:wrap">';
        html += '<strong>' + esc(f.name) + '</strong>';
        if (f.recharge) html += '<span style="color:var(--warning)">(Recharge ' + esc(f.recharge) + ')</span>';
        if (f.usesMax) {
          const remaining = c.featureUses && c.featureUses[fIdx] !== undefined ? c.featureUses[fIdx] : f.usesMax;
          html += '<span style="font-family:var(--mono);font-size:0.72rem;color:' + (remaining === 0 ? 'var(--error)' : 'var(--text-dim)') + '">Uses: ' + remaining + '/' + f.usesMax + '</span>';
          html += '<button class="btn-sm btn-accent"' + (remaining <= 0 ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();useFeature(' + idx + ',' + fIdx + ')"' + (remaining <= 0 ? ' disabled' : '') + '>Use</button>';
          html += '<button class="btn-sm btn-success"' + (remaining >= f.usesMax ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();restoreFeature(' + idx + ',' + fIdx + ')"' + (remaining >= f.usesMax ? ' disabled' : '') + '>Restore</button>';
        }
        if (f.recharge && f.usesMax) {
          const remaining = c.featureUses && c.featureUses[fIdx] !== undefined ? c.featureUses[fIdx] : f.usesMax;
          if (remaining === 0) {
            html += '<button class="btn-sm btn-warning" onclick="event.stopPropagation();rollRecharge(' + idx + ',' + fIdx + ')">Roll Recharge</button>';
          }
        }
        html += '</div>';
        if (f.desc) {
          html += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.15rem">' + renderDiceText(esc(f.desc), idx, 'feature', fIdx) + '</div>';
        }
        html += '</div>';
      });
    }

    // Legendary Actions
    if (template.legendaryActionBudget > 0 && template.legendaryActions.length > 0) {
      const laRemaining = c.legendaryActionsRemaining !== undefined ? c.legendaryActionsRemaining : template.legendaryActionBudget;
      html += '<div class="detail-section-title" style="margin-top:0.5rem">Legendary Actions <span style="font-family:var(--mono);color:var(--warning)">' + laRemaining + '/' + template.legendaryActionBudget + '</span>';
      html += ' <button class="btn-sm btn-success" style="font-size:0.65rem;padding:0.05rem 0.3rem' + (laRemaining >= template.legendaryActionBudget ? ';opacity:0.4' : '') + '" onclick="event.stopPropagation();restoreLegendaryAction(' + idx + ')"' + (laRemaining >= template.legendaryActionBudget ? ' disabled' : '') + '>Restore LA</button>';
      html += '</div>';
      template.legendaryActions.forEach((la, laIdx) => {
        const canUse = laRemaining >= la.cost;
        html += '<div style="margin-bottom:0.4rem;padding:0.3rem 0.5rem;background:var(--bg);border-radius:4px">';
        html += '<div style="font-size:0.75rem;display:flex;align-items:center;gap:0.4rem;flex-wrap:wrap">';
        html += '<strong>' + esc(la.name) + '</strong>';
        html += '<span style="font-family:var(--mono);font-size:0.68rem;color:var(--text-dim)">Cost: ' + la.cost + '</span>';
        html += '<button class="btn-sm btn-accent"' + (!canUse ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();useLegendaryAction(' + idx + ',' + laIdx + ')"' + (!canUse ? ' disabled' : '') + '>Use</button>';
        html += '</div>';
        if (la.desc) {
          html += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.15rem">' + renderDiceText(esc(la.desc), idx, 'la', laIdx) + '</div>';
        }
        html += '</div>';
      });
    }

    // Legendary Resistances
    if (template.legendaryResistances > 0) {
      const lrRemaining = c.legendaryResistancesRemaining !== undefined ? c.legendaryResistancesRemaining : template.legendaryResistances;
      html += '<div class="detail-section-title" style="margin-top:0.5rem">Legendary Resistances <span style="font-family:var(--mono);color:' + (lrRemaining === 0 ? 'var(--error)' : 'var(--text-dim)') + '">' + lrRemaining + '/' + template.legendaryResistances + '</span></div>';
      html += '<div style="display:flex;gap:0.3rem">';
      html += '<button class="btn-sm btn-accent"' + (lrRemaining <= 0 ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();useLegendaryResistance(' + idx + ')"' + (lrRemaining <= 0 ? ' disabled' : '') + '>Use LR</button>';
      html += '<button class="btn-sm btn-success"' + (lrRemaining >= template.legendaryResistances ? ' style="opacity:0.4"' : '') + ' onclick="event.stopPropagation();restoreLegendaryResistance(' + idx + ')"' + (lrRemaining >= template.legendaryResistances ? ' disabled' : '') + '>Restore LR</button>';
      html += '</div>';
    }

    // Tactics
    if (template.tactics) {
      html += '<div class="detail-section-title" style="margin-top:0.5rem">Tactics</div>';
      html += '<div style="font-size:0.75rem;color:var(--text-muted)">' + esc(template.tactics) + '</div>';
    }

    html += '</div>';
  } else if (c.type === 'player') {
    html += '<div><div class="detail-section-title">Player</div>';
    html += '<div style="display:flex;gap:0.5rem;align-items:center;margin-bottom:0.3rem">';
    html += '<label style="font-size:0.75rem;color:var(--text-muted)">AC</label>';
    html += '<input type="number" value="' + (c.ac || '') + '" style="width:60px;padding:0.25rem 0.4rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-family:var(--mono);font-size:0.78rem;text-align:center" onchange="event.stopPropagation();setPlayerAc(' + idx + ',+this.value)" onclick="event.stopPropagation()" placeholder="—">';
    html += '</div>';
    html += '<div style="font-size:0.78rem;color:var(--text-muted)">Conditions and details tracked by the DM.</div>';
    html += '</div><div></div>';
  } else {
    html += '<div><div class="detail-section-title">Ad-hoc Combatant</div>';
    html += '<div style="font-size:0.78rem;color:var(--text-muted)">Lair action, environment effect, or custom entry.</div>';
    html += '</div><div></div>';
  }

  html += '</div>'; // end detail-grid

  // Common controls for all types
  html += '<div style="display:flex;gap:0.5rem;margin-top:0.5rem;align-items:flex-end;flex-wrap:wrap">';
  html += '<div class="form-field" style="width:80px"><label>Init</label>';
  html += '<input type="number" step="0.01" value="' + (c.init !== null && c.init !== undefined ? c.init : '') + '" onchange="event.stopPropagation();editInit(' + idx + ',this.value)" onclick="event.stopPropagation()">';
  html += '</div>';
  html += '<div class="form-field" style="flex:1"><label>Notes</label>';
  html += '<input type="text" value="' + esc(c.notes || '') + '" onchange="event.stopPropagation();setCombatantNotes(' + idx + ',this.value)" onclick="event.stopPropagation()" placeholder="DM notes...">';
  html += '</div>';
  if (c.dead) {
    html += '<button class="btn-sm btn-success" onclick="event.stopPropagation();reviveCombatant(' + idx + ')">Revive</button>';
  } else {
    html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();killCombatant(' + idx + ')">Kill</button>';
  }
  html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();removeCombatant(' + idx + ')">Remove</button>';
  html += '</div>';

  // ── Conditions (all combatant types) ──
  html += '<div style="margin-top:0.5rem">';
  html += '<div class="detail-section-title">Conditions</div>';
  // Existing conditions
  if (c.conditions && c.conditions.length > 0) {
    html += '<div style="display:flex;flex-wrap:wrap;gap:0.3rem;margin-bottom:0.4rem">';
    c.conditions.forEach((cond, condIdx) => {
      html += '<span class="condition-chip' + (cond.durationType === 'save' ? ' save-based' : '') + '" style="font-size:0.68rem;padding:0.15rem 0.4rem">';
      html += esc(cond.name);
      if (cond.durationType === 'rounds' && cond.duration) html += ' (' + cond.duration + 'r)';
      if (cond.durationType === 'save') html += ' (' + cond.saveAbility.toUpperCase() + ' DC' + cond.saveDC + ')';
      if (cond.source) html += ' [' + esc(cond.source) + ']';
      html += ' <button class="btn-remove" style="padding:0.05rem 0.3rem;font-size:0.6rem;margin-left:0.15rem;vertical-align:middle" onclick="event.stopPropagation();removeCondition(' + idx + ',' + condIdx + ')">×</button>';
      html += '</span>';
    });
    html += '</div>';
  }
  // Add condition form
  html += '<div style="display:flex;gap:0.3rem;align-items:flex-end;flex-wrap:wrap;font-size:0.72rem">';
  html += '<select id="condName-' + idx + '" onclick="event.stopPropagation()" style="padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
  CONDITIONS.forEach(cn => { html += '<option value="' + cn + '">' + cn + '</option>'; });
  html += '<option value="__custom__">Custom...</option>';
  html += '</select>';
  html += '<select id="condType-' + idx + '" onclick="event.stopPropagation()" onchange="event.stopPropagation();updateConditionFields(' + idx + ')" style="padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
  html += '<option value="rounds">Rounds</option>';
  html += '<option value="save">Save-based</option>';
  html += '<option value="indefinite">Indefinite</option>';
  html += '</select>';
  html += '<span id="condFields-' + idx + '">';
  html += '<input type="number" id="condDur-' + idx + '" placeholder="rounds" min="1" value="1" onclick="event.stopPropagation()" style="width:55px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem;font-family:var(--mono)">';
  html += '</span>';
  html += '<input type="text" id="condSrc-' + idx + '" placeholder="source" onclick="event.stopPropagation()" style="width:70px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
  html += '<button class="btn-sm btn-accent" onclick="event.stopPropagation();addCondition(' + idx + ')">Add</button>';
  html += '</div>';
  html += '</div>';

  // ── Concentration (all combatant types) ──
  if (c.type !== 'adhoc') {
    html += '<div style="display:flex;gap:0.3rem;align-items:center;margin-top:0.4rem">';
    html += '<span class="detail-section-title" style="margin-bottom:0">Concentration</span>';
    html += '<input type="text" id="concInput-' + idx + '" value="' + esc(c.concentration || '') + '" placeholder="Spell name..." onclick="event.stopPropagation()" onchange="event.stopPropagation();setConcentration(' + idx + ',this.value)" style="flex:1;padding:0.25rem 0.4rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">';
    if (c.concentration) {
      html += '<button class="btn-sm btn-danger" onclick="event.stopPropagation();dropConcentration(' + idx + ')" style="font-size:0.68rem">Drop</button>';
    }
    html += '</div>';
  }

  return html;
}

function toggleCombatantDetail(idx) {
  const c = getActiveCombat().combatants[idx];
  c._expanded = !c._expanded;
  const detailEl = document.getElementById('detail-' + idx);
  if (detailEl) {
    detailEl.classList.toggle('expanded', c._expanded);
  }
}

function setCombatantNotes(idx, value) {
  getActiveCombat().combatants[idx].notes = value;
  saveCombat();
}

function setPlayerAc(idx, value) {
  getActiveCombat().combatants[idx].ac = value || 0;
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Condition Tracking ──
// ═══════════════════════════════════════════════════════════════

function updateConditionFields(idx) {
  const typeEl = document.getElementById('condType-' + idx);
  const fieldsEl = document.getElementById('condFields-' + idx);
  if (!typeEl || !fieldsEl) return;
  const dtype = typeEl.value;
  if (dtype === 'rounds') {
    fieldsEl.innerHTML = '<input type="number" id="condDur-' + idx + '" placeholder="rounds" min="1" value="1" onclick="event.stopPropagation()" style="width:55px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem;font-family:var(--mono)">';
  } else if (dtype === 'save') {
    fieldsEl.innerHTML = '<select id="condSaveAb-' + idx + '" onclick="event.stopPropagation()" style="padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem">' +
      ABILITIES.map(ab => '<option value="' + ab + '">' + ab.toUpperCase() + '</option>').join('') +
      '</select>' +
      '<input type="number" id="condSaveDC-' + idx + '" placeholder="DC" min="1" value="15" onclick="event.stopPropagation()" style="width:45px;padding:0.25rem;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-size:0.72rem;font-family:var(--mono)">';
  } else {
    fieldsEl.innerHTML = '';
  }
}

function addCondition(idx) {
  const c = getActiveCombat().combatants[idx];
  const nameEl = document.getElementById('condName-' + idx);
  const typeEl = document.getElementById('condType-' + idx);
  if (!nameEl || !typeEl) return;

  let name = nameEl.value;
  if (name === '__custom__') {
    name = prompt('Custom condition/effect name:');
    if (!name || !name.trim()) return;
    name = name.trim();
  }

  const durationType = typeEl.value;
  const condition = { name, durationType, source: '' };

  const srcEl = document.getElementById('condSrc-' + idx);
  if (srcEl && srcEl.value.trim()) condition.source = srcEl.value.trim();

  if (durationType === 'rounds') {
    const durEl = document.getElementById('condDur-' + idx);
    condition.duration = Math.max(1, parseInt(durEl && durEl.value) || 1);
  } else if (durationType === 'save') {
    const abEl = document.getElementById('condSaveAb-' + idx);
    const dcEl = document.getElementById('condSaveDC-' + idx);
    condition.saveAbility = abEl ? abEl.value : 'con';
    condition.saveDC = Math.max(1, parseInt(dcEl && dcEl.value) || 15);
  }

  if (!c.conditions) c.conditions = [];
  c.conditions.push(condition);
  setStatus(c.name + ': ' + name + ' condition added', 'success');
  saveCombat();
  render();
}

function removeCondition(idx, condIdx) {
  const c = getActiveCombat().combatants[idx];
  if (!c.conditions || !c.conditions[condIdx]) return;
  const name = c.conditions[condIdx].name;
  c.conditions.splice(condIdx, 1);
  setStatus(c.name + ': ' + name + ' condition removed', 'success');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Concentration Tracking ──
// ═══════════════════════════════════════════════════════════════

function setConcentration(idx, spellName) {
  const c = getActiveCombat().combatants[idx];
  c.concentration = spellName.trim() || null;
  if (c.concentration) {
    setStatus(c.name + ' concentrating on ' + c.concentration, 'success');
  }
  saveCombat();
  render();
}

function dropConcentration(idx) {
  const c = getActiveCombat().combatants[idx];
  const spell = c.concentration;
  c.concentration = null;
  setStatus(c.name + ' dropped concentration' + (spell ? ' on ' + spell : ''), 'warning');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── HP Tracking ──
// ═══════════════════════════════════════════════════════════════

function applyDamage(idx) {
  const input = document.getElementById('hpInput-' + idx);
  if (!input) return;
  const originalDmg = Math.max(0, parseInt(input.value) || 0);
  let dmg = originalDmg;
  if (dmg === 0) return;

  const c = getActiveCombat().combatants[idx];
  const maxHp = resolveField(c, 'hpMax');

  // THP absorbs first
  let tempHp = c.tempHp || 0;
  if (tempHp > 0) {
    const absorbed = Math.min(tempHp, dmg);
    tempHp -= absorbed;
    dmg -= absorbed;
    c.tempHp = tempHp;
  }

  let curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
  curHp -= dmg;
  c.currentHp = Math.max(curHp, 0);

  if (c.currentHp <= 0) {
    c.currentHp = 0;
    c.dead = true;
    setStatus(c.name + ' drops to 0 HP!', 'warning');
  } else {
    setStatus(c.name + ' takes damage. HP: ' + c.currentHp + '/' + maxHp, 'success');
  }

  // Concentration check warning
  if (c.concentration && originalDmg > 0) {
    const dc = Math.max(10, Math.floor(originalDmg / 2));
    setStatus(c.name + ' is concentrating on ' + c.concentration + '! CON save DC ' + dc + ' needed', 'warning');
  }

  saveCombat();
  render();
}

function applyHeal(idx) {
  const input = document.getElementById('hpInput-' + idx);
  if (!input) return;
  const heal = Math.max(0, parseInt(input.value) || 0);
  if (heal === 0) return;

  const c = getActiveCombat().combatants[idx];
  const maxHp = resolveField(c, 'hpMax');
  let curHp = c.currentHp !== undefined ? c.currentHp : maxHp;
  curHp = Math.min(curHp + heal, maxHp);
  c.currentHp = curHp;

  if (curHp > 0 && c.dead) c.dead = false;

  setStatus(c.name + ' healed. HP: ' + curHp + '/' + maxHp, 'success');
  saveCombat();
  render();
}

function applyTempHp(idx) {
  const input = document.getElementById('hpInput-' + idx);
  if (!input) return;
  const val = Math.max(0, parseInt(input.value) || 0);
  if (val === 0) return;
  const c = getActiveCombat().combatants[idx];
  // THP doesn't stack — take the higher value
  c.tempHp = Math.max(c.tempHp || 0, val);
  setStatus(c.name + ' gains ' + val + ' temp HP', 'success');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Feature Use Tracking ──
// ═══════════════════════════════════════════════════════════════

function useFeature(combatantIdx, featureIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  const f = template.features[featureIdx];
  if (!f || !f.usesMax) return;
  if (!c.featureUses) c.featureUses = {};
  if (c.featureUses[featureIdx] === undefined) c.featureUses[featureIdx] = f.usesMax;
  if (c.featureUses[featureIdx] <= 0) return;
  c.featureUses[featureIdx]--;
  setStatus(c.name + ': ' + f.name + ' used (' + c.featureUses[featureIdx] + '/' + f.usesMax + ')', 'success');
  saveCombat();
  render();
}

function restoreFeature(combatantIdx, featureIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  const f = template.features[featureIdx];
  if (!f || !f.usesMax) return;
  if (!c.featureUses) c.featureUses = {};
  if (c.featureUses[featureIdx] === undefined) c.featureUses[featureIdx] = f.usesMax;
  if (c.featureUses[featureIdx] >= f.usesMax) return;
  c.featureUses[featureIdx]++;
  setStatus(c.name + ': ' + f.name + ' restored (' + c.featureUses[featureIdx] + '/' + f.usesMax + ')', 'success');
  saveCombat();
  render();
}

function rollRecharge(combatantIdx, featureIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  const f = template.features[featureIdx];
  if (!f || !f.recharge) return;
  const threshold = parseInt(f.recharge) || 6;
  const result = rollDice('1d6');
  if (!c.rollLog) c.rollLog = [];
  if (!c.featureUses) c.featureUses = {};
  if (result.total >= threshold) {
    c.featureUses[featureIdx] = f.usesMax || 1;
    c.rollLog.push({ label: 'Recharge: ' + esc(f.name), text: 'Rolled ' + result.total + ' (need ' + threshold + '+) — Recharged!', cssClass: 'crit' });
    setStatus(f.name + ' recharged!', 'success');
  } else {
    c.rollLog.push({ label: 'Recharge: ' + esc(f.name), text: 'Rolled ' + result.total + ' (need ' + threshold + '+) — No recharge', cssClass: 'fumble' });
    setStatus(f.name + ' did not recharge', 'warning');
  }
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Legendary Actions & Resistances ──
// ═══════════════════════════════════════════════════════════════

function useLegendaryAction(combatantIdx, laIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  const la = template.legendaryActions[laIdx];
  if (!la) return;
  if (c.legendaryActionsRemaining === undefined) c.legendaryActionsRemaining = template.legendaryActionBudget;
  if (c.legendaryActionsRemaining < la.cost) return;
  c.legendaryActionsRemaining -= la.cost;
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: 'Legendary Action', text: esc(la.name) + ' (cost ' + la.cost + ') — LA ' + c.legendaryActionsRemaining + '/' + template.legendaryActionBudget + ' remaining', cssClass: '' });
  setStatus(c.name + ': ' + la.name + ' (LA ' + c.legendaryActionsRemaining + '/' + template.legendaryActionBudget + ')', 'success');
  saveCombat();
  render();
}

function useLegendaryResistance(combatantIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  if (c.legendaryResistancesRemaining === undefined) c.legendaryResistancesRemaining = template.legendaryResistances;
  if (c.legendaryResistancesRemaining <= 0) return;
  c.legendaryResistancesRemaining--;
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: 'Legendary Resistance', text: 'Used — LR ' + c.legendaryResistancesRemaining + '/' + template.legendaryResistances + ' remaining', cssClass: '' });
  setStatus(c.name + ' uses Legendary Resistance (LR ' + c.legendaryResistancesRemaining + '/' + template.legendaryResistances + ')', 'warning');
  saveCombat();
  render();
}

function restoreLegendaryResistance(combatantIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  if (c.legendaryResistancesRemaining === undefined) c.legendaryResistancesRemaining = template.legendaryResistances;
  if (c.legendaryResistancesRemaining >= template.legendaryResistances) return;
  c.legendaryResistancesRemaining++;
  setStatus(c.name + ': LR restored (' + c.legendaryResistancesRemaining + '/' + template.legendaryResistances + ')', 'success');
  saveCombat();
  render();
}

function restoreLegendaryAction(combatantIdx) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  if (c.legendaryActionsRemaining === undefined) c.legendaryActionsRemaining = template.legendaryActionBudget;
  if (c.legendaryActionsRemaining >= template.legendaryActionBudget) return;
  c.legendaryActionsRemaining++;
  setStatus(c.name + ': LA restored (' + c.legendaryActionsRemaining + '/' + template.legendaryActionBudget + ')', 'success');
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Ability Check / Save Rolling ──
// ═══════════════════════════════════════════════════════════════

function rollAbilityCheck(combatantIdx, ability) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  const mod = abilityMod(template.abilities[ability]);
  const notation = '1d20' + (mod >= 0 ? '+' + mod : String(mod));
  const result = rollDice(notation);
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: ability.toUpperCase() + ' Check', text: esc(result.text) + ' = ' + result.total, cssClass: '' });
  saveCombat();
  renderRollLog(combatantIdx);
}

function rollSavingThrow(combatantIdx, ability) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  // Check for proficient saving throw
  const st = template.savingThrows && template.savingThrows.find(s => s.ability === ability);
  const mod = st ? st.bonus : abilityMod(template.abilities[ability]);
  const notation = '1d20' + (mod >= 0 ? '+' + mod : String(mod));
  const result = rollDice(notation);
  if (!c.rollLog) c.rollLog = [];
  c.rollLog.push({ label: ability.toUpperCase() + ' Save' + (st ? ' (prof)' : ''), text: esc(result.text) + ' = ' + result.total, cssClass: '' });
  saveCombat();
  renderRollLog(combatantIdx);
}

// ═══════════════════════════════════════════════════════════════
// ── Attack Rolling ──
// ═══════════════════════════════════════════════════════════════

function rollAttack(combatantIdx, attackIdx, mode) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  const atk = template.attacks[attackIdx];
  if (!atk) return;

  if (!c.rollLog) c.rollLog = [];
  const notation = '1d20' + (atk.bonus >= 0 ? '+' + atk.bonus : String(atk.bonus));
  const opts = mode === 'advantage' ? { advantage: true } : mode === 'disadvantage' ? { disadvantage: true } : {};
  const result = rollDice(notation, opts);
  const d20 = mode ? (result.rolls.length === 2 ? (mode === 'advantage' ? Math.max(...result.rolls) : Math.min(...result.rolls)) : result.rolls[0]) : result.rolls[0];
  const critThreshold = template.critRange || 20;
  const isCrit = d20 >= critThreshold;
  const critClass = isCrit ? 'crit' : d20 === 1 ? 'fumble' : '';
  const critLabel = isCrit ? ' — NAT 20!' : d20 === 1 ? ' — NAT 1' : '';
  const modeLabel = mode === 'advantage' ? ' (Adv)' : mode === 'disadvantage' ? ' (Dis)' : '';

  c.rollLog.push({
    label: esc(atk.name) + ' Attack' + modeLabel,
    text: esc(result.text) + ' (total: ' + result.total + ')' + critLabel,
    cssClass: critClass
  });
  saveCombat();
  renderRollLog(combatantIdx);
}

function rollDamageForAttack(combatantIdx, attackIdx, crit) {
  const c = getActiveCombat().combatants[combatantIdx];
  const template = getTemplate(c);
  if (!template) return;
  const atk = template.attacks[attackIdx];
  if (!atk || !atk.damages || atk.damages.length === 0) return;

  if (!c.rollLog) c.rollLog = [];
  let parts = [];
  let grandTotal = 0;
  atk.damages.forEach(dm => {
    if (!dm.dice || !dm.dice.trim()) return;
    let dice = dm.dice.trim();
    if (crit) {
      // Double the dice count: NdM+X → (2N)dM+X
      const m = dice.match(/^(\d+)(d\d+.*)$/i);
      if (m) dice = (parseInt(m[1]) * 2) + m[2];
    }
    const result = rollDice(dice);
    grandTotal += result.total;
    let text = result.total + ' ' + (dm.type || 'untyped');
    text += ' (' + result.text + ')';
    if (dm.note) text += ' [' + dm.note + ']';
    parts.push(text);
  });

  c.rollLog.push({
    label: esc(atk.name) + (crit ? ' Crit Damage' : ' Damage'),
    text: esc(parts.join(' + ')) + ' = ' + grandTotal,
    cssClass: crit ? 'crit' : ''
  });
  saveCombat();
  renderRollLog(combatantIdx);
}

function renderRollLog(combatantIdx) {
  const el = document.getElementById('rollLog-' + combatantIdx);
  if (!el) return;
  const c = getActiveCombat().combatants[combatantIdx];
  if (!c.rollLog || c.rollLog.length === 0) { el.innerHTML = ''; return; }
  let html = '<div class="roll-log">';
  c.rollLog.forEach(entry => {
    html += '<div class="roll-log-entry ' + (entry.cssClass || '') + '">';
    html += '<strong>' + entry.label + ':</strong> ' + entry.text;
    html += '</div>';
  });
  html += '</div>';
  el.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// ── Turn Management ──
// ═══════════════════════════════════════════════════════════════

function applyTurnStartEffects(idx) {
  const c = getActiveCombat().combatants[idx];
  const template = getTemplate(c);
  c.reactionUsed = false;
  c.rollLog = [];

  // Feature recharge prompts (DM-initiated)
  if (template && template.features) {
    template.features.forEach((f, fIdx) => {
      if (f.recharge && f.usesMax) {
        const remaining = c.featureUses && c.featureUses[fIdx] !== undefined ? c.featureUses[fIdx] : f.usesMax;
        if (remaining === 0) {
          c.rollLog.push({ label: 'Recharge Available', text: esc(f.name) + ' — open detail panel to Roll Recharge', cssClass: '' });
        }
      }
    });
  }

  // Legendary action recharge
  if (template && template.legendaryActionBudget > 0) {
    c.legendaryActionsRemaining = template.legendaryActionBudget;
  }

  // Condition duration decrement & save reminders
  if (c.conditions && c.conditions.length > 0) {
    c.conditions = c.conditions.filter(cond => {
      if (cond.durationType === 'rounds') {
        cond.duration--;
        if (cond.duration <= 0) {
          c.rollLog.push({ label: 'Condition Expired', text: cond.name + ' has worn off', cssClass: '' });
          return false;
        }
        c.rollLog.push({ label: 'Condition', text: cond.name + ' — ' + cond.duration + ' round' + (cond.duration !== 1 ? 's' : '') + ' remaining', cssClass: '' });
      } else if (cond.durationType === 'save') {
        c.rollLog.push({ label: 'Save Needed', text: cond.name + ' — ' + cond.saveAbility.toUpperCase() + ' save DC ' + cond.saveDC, cssClass: '' });
      }
      return true;
    });
  }
}

function nextTurn() {
  const combat = getActiveCombat();
  if (!combat || combat.round < 1) return;

  const startIdx = combat.turnIndex;
  let next = startIdx;
  let wrapped = false;

  do {
    next++;
    if (next >= combat.combatants.length) {
      next = 0;
      wrapped = true;
    }
    if (next === startIdx) break;
  } while (combat.combatants[next].dead);

  if (wrapped) combat.round++;

  combat.turnIndex = next;
  applyTurnStartEffects(next);

  setStatus('Round ' + combat.round + ' — ' + combat.combatants[next].name + '\'s turn', 'success');
  saveCombat();
  render();
}

function prevTurn() {
  const combat = getActiveCombat();
  if (!combat || combat.round < 1) return;

  const startIdx = combat.turnIndex;
  let prev = startIdx;
  let wrapped = false;

  do {
    prev--;
    if (prev < 0) {
      prev = combat.combatants.length - 1;
      wrapped = true;
    }
    if (prev === startIdx) break;
  } while (combat.combatants[prev].dead);

  if (wrapped) combat.round = Math.max(1, combat.round - 1);

  combat.turnIndex = prev;

  setStatus('Round ' + combat.round + ' — ' + combat.combatants[prev].name + '\'s turn', 'success');
  saveCombat();
  render();
}

function toggleReaction(idx) {
  getActiveCombat().combatants[idx].reactionUsed = !getActiveCombat().combatants[idx].reactionUsed;
  saveCombat();
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Mid-Combat Editing ──
// ═══════════════════════════════════════════════════════════════

function editInit(idx, value) {
  const combat = getActiveCombat();
  const isCurrentTurn = (idx === combat.turnIndex);
  combat.combatants[idx].init = value === '' ? null : +value;

  if (isCurrentTurn && combat.round >= 1) {
    // Dropping init ends your turn: find the next combatant in current order before re-sorting
    let nextIdx = combat.turnIndex;
    do {
      nextIdx++;
      if (nextIdx >= combat.combatants.length) { nextIdx = 0; combat.round++; }
      if (nextIdx === combat.turnIndex) break;
    } while (combat.combatants[nextIdx].dead);
    const nextId = combat.combatants[nextIdx].id;
    applyTurnStartEffects(nextIdx);
    combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
    combat.turnIndex = combat.combatants.findIndex(c => c.id === nextId);
    if (combat.turnIndex < 0) combat.turnIndex = 0;
    setStatus('Round ' + combat.round + ' — ' + combat.combatants[combat.turnIndex].name + '\'s turn', 'success');
  } else {
    // Non-current combatant: re-sort, preserve current turn
    const currentId = combat.combatants[combat.turnIndex].id;
    combat.combatants.sort((a, b) => (b.init ?? -Infinity) - (a.init ?? -Infinity));
    combat.turnIndex = combat.combatants.findIndex(c => c.id === currentId);
    if (combat.turnIndex < 0) combat.turnIndex = 0;
  }

  saveCombat();
  render();
}

function killCombatant(idx) {
  const c = getActiveCombat().combatants[idx];
  c.dead = true;
  if (c.type === 'monster') c.currentHp = 0;
  setStatus(c.name + ' is dead.', 'warning');
  saveCombat();
  render();
}

function reviveCombatant(idx) {
  const c = getActiveCombat().combatants[idx];
  c.dead = false;
  if (c.type === 'monster' && (c.currentHp === undefined || c.currentHp <= 0)) c.currentHp = 1;
  setStatus(c.name + ' is back!', 'success');
  saveCombat();
  render();
}

function removeCombatant(idx) {
  const combat = getActiveCombat();
  const c = combat.combatants[idx];
  if (!confirm('Remove ' + c.name + ' from combat?')) return;

  if (idx < combat.turnIndex) {
    combat.turnIndex--;
  } else if (idx === combat.turnIndex && combat.turnIndex >= combat.combatants.length - 1) {
    combat.turnIndex = 0;
  }

  combat.combatants.splice(idx, 1);
  if (combat.combatants.length === 0) { endCombat(); return; }
  if (combat.turnIndex >= combat.combatants.length) combat.turnIndex = 0;

  saveCombat();
  render();
}

function endCombat() {
  const active = getActiveCombat();
  if (active && active.round >= 1) {
    if (!confirm('End combat? This cannot be undone.')) return;
  }
  state.combats = state.combats.filter(c => c.id !== activeCombatId);
  activeCombatId = null;
  pendingCombatEncounterId = null;
  saveCombat();
  setStatus('Combat ended.', 'warning');
  render();
}

// ═══════════════════════════════════════════════════════════════
// ── Import / Export ──
// ═══════════════════════════════════════════════════════════════

async function exportData() {
  try {
    const payload = {
      version: 1,
      exported: new Date().toISOString(),
      templates: state.templates,
      encounters: state.encounters,
      parties: state.parties,
      combats: state.combats
    };
    const json = JSON.stringify(payload);
    const compressed = await compress(json);
    const header = '[SquishText] To decode, base64-decode the string below then inflate (deflate-raw). Or paste at https://promptferret.github.io/tools/squishtext/\n';
    const blob = header + compressed;
    const file = new Blob([blob], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(file);
    a.download = 'encounter-backup-' + new Date().toISOString().slice(0, 10) + '.squishtext';
    a.click();
    URL.revokeObjectURL(a.href);
    setStatus('Backup exported!', 'success');
  } catch (e) {
    console.error('Export failed:', e);
    setStatus('Export failed: ' + e.message, 'error');
  }
}

function showImportDialog() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.squishtext';
  input.onchange = async function() {
    if (!input.files.length) return;
    try {
      const text = await input.files[0].text();
      const decompressed = await decompress(text);
      const data = JSON.parse(decompressed);
      if (!data.templates && !data.encounters) throw new Error('Invalid backup format');
      const existingIds = new Set();
      function mergeArray(existing, incoming) {
        existing.forEach(item => existingIds.add(item.id));
        let added = 0;
        (incoming || []).forEach(item => {
          if (!existingIds.has(item.id)) { existing.push(item); added++; }
        });
        existingIds.clear();
        return added;
      }
      let added = 0;
      added += mergeArray(state.templates, data.templates);
      added += mergeArray(state.encounters, data.encounters);
      added += mergeArray(state.parties, data.parties);
      added += mergeArray(state.combats, data.combats);
      activeCombatId = null;
      save();
      setStatus('Backup loaded! ' + added + ' new item' + (added !== 1 ? 's' : '') + ' added, duplicates skipped.', 'success');
      render();
      updateStorageInfo();
    } catch (e) {
      console.error('Import failed:', e);
      setStatus('Import failed: ' + e.message, 'error');
    }
  };
  input.click();
}

// ── Monster Import / Export ──

async function exportMonster(id) {
  const t = state.templates.find(t => t.id === id);
  if (!t) { setStatus('Monster not found.', 'error'); return; }
  try {
    const payload = { version: 1, exported: new Date().toISOString(), templates: [t] };
    const json = JSON.stringify(payload);
    const compressed = await compress(json);
    const header = '[SquishText] To decode, base64-decode the string below then inflate (deflate-raw). Or paste at https://promptferret.github.io/tools/squishtext/\n';
    const file = new Blob([header + compressed], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(file);
    a.download = (t.name || 'monster').replace(/[^a-zA-Z0-9_-]/g, '_') + '.squishtext';
    a.click();
    URL.revokeObjectURL(a.href);
    setStatus('Exported: ' + t.name, 'success');
  } catch (e) {
    setStatus('Export failed: ' + e.message, 'error');
  }
}

function showImportMonsterDialog() {
  const existing = document.getElementById('importModal');
  if (existing) existing.remove();
  const modal = document.createElement('div');
  modal.id = 'importModal';
  modal.className = 'modal-overlay';
  modal.innerHTML = '<div class="modal-content">' +
    '<div class="form-section-title" style="margin-bottom:0.75rem">Import Monsters</div>' +
    '<p style="font-size:0.78rem;color:var(--text-muted);margin-bottom:0.75rem">Select one or more .squishtext files containing monster templates.</p>' +
    '<input type="file" id="importFileInput" accept=".squishtext" multiple style="margin-bottom:1rem;font-size:0.8rem;color:var(--text)">' +
    '<p style="font-size:0.7rem;color:var(--text-muted);margin-bottom:1rem">New monsters will be added. Existing monsters are kept (duplicates skipped by ID).</p>' +
    '<div style="display:flex;gap:0.5rem;justify-content:flex-end">' +
    '<button class="btn-sm" onclick="document.getElementById(\'importModal\').remove()">Cancel</button>' +
    '<button class="btn-sm btn-action" onclick="doImportMonster()">Import</button>' +
    '</div></div>';
  document.body.appendChild(modal);
}

async function doImportMonster() {
  const fileInput = document.getElementById('importFileInput');
  if (!fileInput || !fileInput.files.length) {
    setStatus('Select a file first.', 'warning');
    return;
  }
  try {
    const existingIds = new Set(state.templates.map(t => t.id));
    let added = 0, dupes = 0, totalFound = 0;
    for (const file of fileInput.files) {
      const text = await file.text();
      const decompressed = await decompress(text);
      const data = JSON.parse(decompressed);
      if (!data.templates || !data.templates.length) continue;
      totalFound += data.templates.length;
      data.templates.forEach(t => {
        if (!existingIds.has(t.id)) { state.templates.push(t); existingIds.add(t.id); added++; }
        else { dupes++; }
      });
    }
    if (totalFound === 0) throw new Error('No monster templates found in selected files');
    save('templates');
    const modal = document.getElementById('importModal');
    if (modal) modal.remove();
    setStatus('Imported ' + added + ' monster' + (added !== 1 ? 's' : '') + (dupes > 0 ? ' (' + dupes + ' duplicate' + (dupes !== 1 ? 's' : '') + ' skipped)' : '') + '.', 'success');
    render();
  } catch (e) {
    console.error('Monster import failed:', e);
    setStatus('Import failed: ' + e.message, 'error');
  }
}

// ═══════════════════════════════════════════════════════════════
// ── Storage Indicator ──
// ═══════════════════════════════════════════════════════════════

function updateStorageInfo() {
  if (!navigator.storage || !navigator.storage.estimate) return;
  navigator.storage.estimate().then(est => {
    const el = document.getElementById('storageInfo');
    if (!el) return;
    function fmt(b) {
      if (b < 1024) return b + ' B';
      if (b < 1024 * 1024) return (b / 1024).toFixed(1) + ' KB';
      if (b < 1024 * 1024 * 1024) return (b / (1024 * 1024)).toFixed(1) + ' MB';
      return (b / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
    }
    el.textContent = 'Storage: ' + fmt(est.usage || 0) + ' / ' + fmt(est.quota || 0);
  }).catch(() => {});
}

// ═══════════════════════════════════════════════════════════════
// ── Init ──
// ═══════════════════════════════════════════════════════════════

load().then(() => { render(); updateStorageInfo(); });
</script>

</body>
</html>
